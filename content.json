{"posts":[{"title":"(Error) git init으로 프로젝트 시작하기 vs git clone으로 프로젝트 시작하기","text":"상황 설명 로컬에서 hexo blog framework로 blog 구축 project를 시작함. github에서 github blog 생성하기 위해 repo 생성. 위의 원격 repo에 hexo-deployer-git plugin을 사용하여 deploy함. hexo project에서 static file들은 public폴더에서 관리하므로, git으로 버전 관리를 하기 위해 public 폴더에 git init 시전. 에러 메세지들 123$ git push origin mainerror: src refspec main does not match anyerror: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git' remote에는 master branch가 없기 때문에 출력된 에러 메세지 123456789$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (fetch first)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. remote에 있는 것들이 당연하게 내 local에도 있어야 하는데, 없으니까 일단 pull로 땡겨와라. 라는 메세지 12345678910$ git pull origin mainremote: Enumerating objects: 46, done.remote: Counting objects: 100% (46/46), done.remote: Compressing objects: 100% (27/27), done.remote: Total 46 (delta 9), reused 46 (delta 9), pack-reused 0Unpacking objects: 100% (46/46), 129.91 KiB | 601.00 KiB/s, done.From https://github.com/bongsee/bongsee.github.io * branch main -&gt; FETCH_HEAD * [new branch] main -&gt; origin/mainfatal: refusing to merge unrelated histories 관련 없는 기록 병합 거부 remote의 commit history와 local의 commit history가 관련성이 없기 때문에 merge하는데 실패하는 것 기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit지점이 존재해야 한다.그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit이 없기때문에 pull 명령어를 사용할 수 없는 것이다. 12345678$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (non-fast-forward)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 힌트 : 현재 지점의 끝이 원격 지점 뒤에 있기 때문에 업데이트가 거부되었습니다. 다시 푸시하기 전에 원격 변경 사항을 통합하십시오. rejected : push가 거부되었다. master -&gt; master : 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 했는데 non-fast-forward : 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다. 라는 의미이다. 그럼 git push는 내부적으로 어떻게 할지말지를 판단하나 ? push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다.그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 정리 애초에 접근부터가 잘못됐다. (git clone)원격 repo에서 프로젝트를 시작했으면, 해당 repo를 clone해와서 repo와 local을 동기화시킨 이후에 작업을 해야하는 것이고, (git init)local에서 프로젝트를 시작했으면, remote에 대한 설정과 upstream 링크를 걸어주는 등의 작업을 직접해야하는 것이다. 결론은 어쨌든 연결되는 공통된 커밋 포인트가 없다는 것. 아~ 최우영 강사님,, 이제야 깨닫습니다. 왜 remote에서 시작해서 clone하는게 편한지요… Refs https://jobc.tistory.com/177","link":"/2022/12/19/221219_error_git/"},{"title":"Data Format에 대해","text":"Data Format (22.12.17)Focus 데이터 포맷이 왜 필요할까 ? JSON YAML 데이터 직렬화/역직렬화 1. 데이터 포맷이 왜 필요할까 ? 혼자 개발하거나, 내부적으로 데이터를 사용할 땐 내부의 규칙을 문서화하고 참고하면 그만이지만, 문제는 타인 또는 타 시스템과 연동을 해야할 때다. 데이터를 주고 받을 때 마다 각자 정해진 규칙을 문서로 주고 받는 것도 비효율적이고, 하나의 통일된 규칙이 없을 때 생기는 불필요한 문서들이 많아지기 마련임. 이렇게 상호가 데이터를 효율적으로 다루고자 통일된 규칙을 가지는 ‘format’이 등장하게 된다. XML, JSON, YAML 등이 있다. 2. JSON JSON 데이터 포맷 예시1234567891011121314151617181920212223242526272829303132{ &quot;name&quot;: &quot;Rust&quot;, &quot;on&quot;: { &quot;push&quot;: { &quot;branches&quot;: [&quot;master&quot;] }, &quot;pull_request&quot;: { &quot;branches&quot;: [&quot;master&quot;] } }, &quot;env&quot;: { &quot;CARGO_TERM_COLOR&quot;: &quot;always&quot; }, &quot;jobs&quot;: { &quot;build&quot;: { &quot;runs-on&quot;: &quot;ubuntu-latest&quot;, &quot;steps&quot;: [ { &quot;uses&quot;: &quot;actions/checkout@v2&quot; }, { &quot;name&quot;: &quot;Build&quot;, &quot;run&quot;: &quot;cargo build --verbose&quot; }, { &quot;name&quot;: &quot;Run tests&quot;, &quot;run&quot;: &quot;cargo test --verbose&quot; } ] } }} 데이터 직렬화에 유리하여 일반적으로 데이터 전송, AJAX 통신 등 API 통신에 주로 사용됨. XML은 헤더와 태그 등으로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 있었던 데 반해 JSON은 나은 가독성, 효율성을 가진다. 주석을 지원하지 않는다. 데이터 타입을 강제하려면 JSON 스키마로 보완해야한다. 3. YAML YAML 데이터 포맷 예시123456789101112131415161718#!syntax yamlname: Ruston: push: branches: [master] pull_request: branches: [master]env: CARGO_TERM_COLOR: alwaysjobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Build run: cargo build --verbose - name: Run tests run: cargo test --verbose​ 주로 수정이 잦은 설정(conf) 파일에 사용됨. XML, JSON 보다 직관적이라 가독성이 좋다. 주석이 가능하다. 데이터 타입을 명시해줄 수 있다. 데이터 직렬화가 불편하다. 4. 데이터 직렬화/역직렬화 : (보완, 수정 요 - 운영체제) 직렬화(Serialization)란, 참조 타입의 데이터를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형태로 변환하는 작업임. 역직렬화(Deserialization)란, 디스크에 저장된 데이터를 읽거나, 네트워크를 통해 전송받은 데이터를 메모리에 저장하기 위한 형태로 변환하는 작업임. 메모리에서 데이터가 가지는 구조는 2가지다. 값(Value) 형식 데이터 참조(Reference) 형식 데이터 : 객체 타입이 여기에 해당. 이 두가지 데이터 중 디스크에 저장하거나 네트워크 통신을 할 수 있는 데이터는 값(Value) 형식의 데이터다. 직렬화를 통해 참조 형태의 데이터를 값 형태로 변환.","link":"/2022/12/19/221218_data_format/"},{"title":"Mark down 문법 정리(+ 업데이트 중)","text":"* 구분선--- * 텍스트 강조**강조될 텍스트** 강조될 텍스트 / 일반 텍스트 * 이미지 삽입![이미지 이름](이미지 주소) * 줄 바꿈엔터 두번 * 줄 여러번 바꾸기&lt;br&gt; 2022-12-24 추가 업데이트Markdown file에서 이미지 크기 조절하기 기존의 이미지 삽입과 다른 방식을 사용. img tag를 활용할 수 있다. &lt;img src=&quot;이미지 주소&quot; width=&quot;원하는 가로너비&quot; height=&quot;원하는 세로너비&quot;&gt;","link":"/2022/12/18/221218_markdown/"},{"title":"221219, 221220 TIL (html, css)","text":"박영웅 강사님의 html, css 강의 인상 깊었던 멘트 어떤 사이트를 클론할 땐 가장 먼저 해야할 것은 ‘구조화’이다. 모든 layout은 위에서 아래로 쌓인다. 세세한 수치는 개발자 도구에서 찾아서 쓰기 브라우저가 기본적으로 제공하는 값들이 존재한다. –&gt; 브라우저의 기본 셋팅값을 초기화 시킨 후 진행 css 속성들의 default 값을 먼저 알아라. 내가 직접 지정하지 않아도 설정되어있는 값을 아는 것이 먼저! 그 후에 제대로 된 조작이 가능! ‘검증’에 대한 고찰 어떤 코드를 검증하고자 할 땐 주변 코드를 배제시키고 백지에 검증하고자 하는 코드만 놓고 봐야한다. 그렇지 않으면 주변 코드에 의해 오염될 가능성이 높아지고, 검증의 신뢰도는 급격히 떨어짐. KeywordsHTML html 전역속성 DOCTYPE의 의미 data-xxx 속성 tabIndex, contenteditable 속성 HTML Entity 그럼에도 불구하고 Semantic tag를 지향해야하는 이유 CSS vector image / bitmap image scss / css framework / css in js viewport image sprite CSS 선택자 종류 inline element / block element inline요소는 본질적으로 layout을 다루기 위한 것이 아닌, 글자를 제어하기 위한 용도이다. 따라서 inline 요소는 너비값인 width와 height 속성을 부여해도 동작하지 않는다. width와 height의 default : auto &amp; 그 의미 CSS 선택자 읽는 법 가상 클래스 선택자 / 가상 요소 선택자 CSS 상속 상속이 되는 속성 postion : absolute에 대한 고찰 강제 상속 inherit 선택자 명시도 box-sizing : border-box etc cross browsing Emmet 문법","link":"/2022/12/22/221219-htmlcss/"},{"title":"(프로그래머스 lv0) 두수의 나눗셈 알고리즘 풀이","text":"문제 설명 정수 num1과 num2가 매개변수로 주어질 때, num1을 num2로 나눈 값에 1,000을 곱한 후 정수 부분을 return 하도록 soltuion 함수를 완성해주세요. 제한사항 0 ≤ num1 ≤ 100 0 ≤ num2 ≤ 100 입출력 예 num1 num2 result 3 2 1500 7 3 2333 1 16 62 입출력 예 설명 입출력 #1 : num1이 3, num2가 2이므로 3 / 2 = 1.5에 1,000을 곱하면 1500이 됩니다. 입출력 #2 : num1이 7, num2가 3이므로 7 / 3 = 2.33333…에 1,000을 곱하면 2333.3333…. 이 되며, 정수 부분은 2333입니다. 나의 풀이12345function solution(num1, num2) { let answer = 0; answer = Math.floor((num1 / num2) * 1000); return answer;} 회고 연산자 우선순위를 고려하면 다음의 코드를 수정할 수 있겠다. 곱하기, 나누기, 나머지 연산자는 같은 레벨의 우선순위를 가지며, 좌결합성의 연산자이다. (num1 / num2) * 1000 -&gt; num1 / num2 * 1000 즉, 괄호는 불필요함. 다만, 가독성을 고려하면 개인적으로 전자가 코드의 의도를 읽기 쉬워보임. 연산자 우선순위 ref","link":"/2022/12/22/221221-algo-%EB%91%90%EC%88%98%EC%9D%98%EB%82%98%EB%88%97%EC%85%88/"},{"title":"(프로그래머스 lv0) 분수의 덧셈 알고리즘 풀이","text":"문제 설명 첫 번째 분수의 분자와 분모를 뜻하는 denum1, num1, 두 번째 분수의 분자와 분모를 뜻하는 denum2, num2가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 &lt; denum1, num1, denum2, num2 &lt; 1,000 입출력 예 denum1 num1 denum2 num2 result 1 2 3 4 [5, 4] 9 2 1 3 [29, 6] 입출력 예 설명 입출력 #1 : 1 / 2 + 3 / 4 = 5 / 4입니다. 따라서 [5, 4]를 return 합니다. 입출력 #2 : 9 / 2 + 1 / 3 = 29 / 6입니다. 따라서 [29, 6]을 return 합니다. 나의 풀이1234567891011function solution(denum1, num1, denum2, num2) { let denum = denum1 * num2 + denum2 * num1; // 통분 후의 분자 let num = num1 * num2; // 통분 후의 분모 let divider; // 추가적으로 나눠야 하는가 ? 최대공약수 구하기 for (let i = 1; i &lt;= Math.min(denum, num); i++) { if (denum % i === 0 &amp;&amp; num % i === 0) { divider = i; } } return [denum / divider, num / divider];} 회고 최대공약수라는 개념을 아예 잊고 지냈는데, 다시 만나니까 반갑지 않다.","link":"/2022/12/22/221222-algo-%EB%B6%84%EC%88%98%EC%9D%98%EB%8D%A7%EC%85%88/"},{"title":"(프로그래머스 lv0) 최빈값 구하기 알고리즘 풀이","text":"문제 설명 최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다. 제한사항 0 &lt; array의 길이 &lt; 100 0 ≤ array의 원소 &lt; 1000 입출력 예 array result [1,2,3,3,3,4] 3 [1,1,2,2] -1 [1] 1 입출력 예 설명 입출력 #1 : [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다. 입출력 #2 : [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다. 입출력 #3 : [1]에는 1만 있으므로 최빈값은 1입니다. 나의 풀이12345678910111213141516171819202122232425function solution(array) { let numObj = {}; let max = 0; let answer = -1; // numObj 객체에 배열의 각 요소별 개수 정보를 입력 for (let num of array) { numObj[num] ? (numObj[num] += 1) : (numObj[num] = 1); } // 가장 높은 빈도수를 max에 할당 for (let key in numObj) { max = Math.max(max, numObj[key]); } // max 빈도수를 가진 요소를 출력 for (let key in numObj) { // max 빈도수가 중복이라면 -1 반환 if (numObj[answer] === numObj[key]) { return -1; } // max 빈도수값을 가지는 요소를 반환 if (numObj[key] === max) { answer = parseInt(key); } } return answer;} 회고 객체의 key값은 항상 타입이 문자열임을 잊지말자. 분명 더 쉬운 방법이 있을 것 같은데 다시 한번 들춰봐야할 것 같다.","link":"/2022/12/22/221222-algo-%EC%B5%9C%EB%B9%88%EA%B0%92%EA%B5%AC%ED%95%98%EA%B8%B0/"},{"title":"(프로그래머스 lv0) 옷가게 할인받기 알고리즘 풀이","text":"문제 설명 머쓱이네 옷가게는 10만 원 이상 사면 5%, 30만 원 이상 사면 10%, 50만 원 이상 사면 20%를 할인해줍니다.구매한 옷의 가격 price가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요. 제한사항 10 ≤ price ≤ 1,000,000 price는 10원 단위로(1의 자리가 0) 주어집니다. 소수점 이하를 버린 정수를 return합니다. 입출력 예 price result 150,000 142,500 580,000 464,000 입출력 예 설명 입출력 #1 : 150,000원에서 5%를 할인한 142,500원을 return 합니다. 입출력 #2 : 580,000원에서 20%를 할인한 464,000원을 return 합니다. 나의 풀이1234567891011121314function solution(price) { const level1 = 1 - 0.05; const level2 = 1 - 0.1; const level3 = 1 - 0.2; if (price &gt;= 500_000) { return Math.floor(price * level3); } else if (price &gt;= 300_000) { return Math.floor(price * level2); } else if (price &gt;= 100_000) { return Math.floor(price * level1); } else { return price; }} 회고 조건이 여러개 달리기 때문에 switch문을 사용해보면 어떨까했다. switch문의 case 뒤에 오는 건 조건이 아니라 값이다. 즉, 조건이 와버리면 값으로 평가해버리기 때문에 Boolean 값으로 자동 형변환이 진행된다. 또한 switch문은 기준이 되는 값과 case뒤에 오는 값의 일치여부(일치 연산자 ===)를 보기 때문에 아래의 코드는 내 의도와는 다르게 동작할 수 있다. 1234567891011121314function solution(price) { const level1 = 0.05; const level2 = 0.1; const level3 = 0.2; switch (price) { case price &gt;= 500_000: // &quot;price가 price &gt;= 500_000이라면&quot; 으로 해석이 되는 것이 아니라, 'price &gt;= 500_000'는 Boolean값으로 평가되기 때문에 'price === true라면', 또는 'price === false 라면' 으로 해석되는 것. return price * (1 - level3); case price &gt;= 300_000: return price * (1 - level2); case price &gt;= 100_000: return price * (1 - level1); }} swicth문은 case 뒤에 오는 값을 하나로 특정지을 수 있고, 그 값을 기준값과 비교하려고 할 때 써야할 것 같다. 논외로 switch문 사용하면서 들었던 의문을 정리해본다. 함수 내부의 switch문에서 반복문의 종료로 return을 사용할 수 있다. 다만 break는 switch문만을 탈출하고 함수 내부의 흐름으로 넘어가는 반면, return을 사용할 경우 switch문을 탈출하는 것 뿐 아니라, switch문이 위치해있던 함수도 종료함으로써 함수를 호출했던 context로 실행 흐름이 넘어간다.","link":"/2022/12/24/221224-algo-%EC%98%B7%EA%B0%80%EA%B2%8C%ED%95%A0%EC%9D%B8%EB%B0%9B%EA%B8%B0/"},{"title":"221223 TIL (html, css)","text":"박영웅 강사님의 html, css 강의이 포스트는 heropy blog의 post를 참조합니다. 인상 깊었던 멘트 정렬과 배치는 다른 개념이다. margin : auto는 배치를 하는 것이지 정렬의 개념이 아니라는 것. 명시적 !== 암시적 Flex 요소 Flex Container &amp; Flex item (각각에 적용할 수 있는 속성은 정해져있다.) Flex Container : display, flex-flow(flex-direction + flex-wrap), justify-content, align-content, align-items Flex item : order, align-self, flex(flex-grow, flex-shrink, flex-basis) Flex item 들은 block 요소처럼 동작하지만, 일반적인 block요소와는 다르게 width를 최대한 적게 가져간다. 추가적으로 강사님 블로그인 heropy blog에서 관련 공부 중에 display : flex와 display : inline-flex의 차이를 보여주는 그림에서 flex container와 flex item를 이해하는데 도움이 될 것 같은 그림을 퍼왔다. main axix &amp; cross axis / 시작점(start), 끝점(end) flex-direction에 따라 변화(상대적인 개념) 개별속성과 단축속성 간혹 단축속성에서 default값이 변화하는 부분이 발생하므로 주의하도록. 가급적 개별속성을 쓰는게 좋아보인다. Flex container의 정렬 속성에서 사용되는 단어의 의미 파헤치기 justify : main axis에 적용되는 정렬 align : cross axis에 적용되는 정렬 content : axis에 존재하는 줄이 여러개일 때 줄들 사이의 규칙을 적용할 때 사용. (2줄 이상) 예를 들어, flex container의 flex-direction이 row(default)일 때, flex-wrap : wrap 속성이 없다면 align-content 속성이 적용 안된다. (한 줄이기 때문에) items : axis에 존재하는 각각의 줄에 적용 (개별적용) space-xxx : 남는 공간/공백(space)를 어떻게 활용할 것 인가? 에 대한 속성 flex item의 정렬 속성에서 flex 속성 파헤치기 (item의 너비에 관한 속성)괄호 안은 해당 속성이 가지는 default 값 입니다. (default) flex item들은 한 줄 안에 모두 들어가려함. (flex-wrap : nowrap;) flex-grow (0) : item의 증가 너비 비율을 지정 (여기서 증가하는 부분은 main-axis방향으로, flex-direction에 따라 width가 될 수도, height가 될 수도.) flex-shrink (1) : item의 감소 너비 비율을 지정 (마찬가지.) flex-basis (auto) : item의 기본 너비 설정 auto : item의 content 너비를 제거한 공백 기준으로 계산 0 : content 너비를 포함한 계산 (우리가 보통 상상하는 그림이 이 값을 통해 나옴.) (주의)단축 속성으로 사용시 flex-basis의 default 값이 0으로 변화 Positionposition : static position의 기본값. position : absolute 적용된 요소는 자동으로 block요소로 동작한다. 주변과의 상호작용이 끊김. 위치 상의 부모를 찾는다. (없다면 viewport를 기준으로 동작) 위치 상의 부모를 지정해주기 위해 position : relative를 조상 요소 중 하나에 적용시킨다. (가급적 가까운 부모에 해주기) position : fixed 적용된 요소는 자동으로 block요소로 동작한다. 주변과의 상호작용이 끊김. viewport 기준으로 동작 (주의) transform, perspective, filter 의 속성 중 하나가 조상 요소 중에 적용이 되어있다면 해당 요소를 기준으로 동작함. 외울 필요는 없어보이고, fixed가 내 예상과는 달리 동작한다면 해당 케이스를 의심해볼 정도면 될 것으로 보인다. position : relative 자기 자신을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용 그러나, 위의 목적으로 쓰기에는 layout 해석 및 코드 유지보수의 관점에서 매우 불리해진다. relative는 주변과의 상호작용은 유지되면서 시각적으로 렌더링되는 위치만 옮겨지는 것이기 때문. (박영웅 강사님의 택배박스 neck slice 예시) transform : translate()으로 대체 가능. 그럼 어디에 쓰느냐 ? position : absolute가 적용된 요소의 기준점을 설정할 때 사용. position : sticky top, right, bottom, left의 값 중 하나 이상 적용이 되어야 동작한다. ETCbackground-image 속성 background-image : url() background-size : cover / contain cover : 이미지가 찌그러지지 않는 한도 내에서 제일 크게 설정. 이미지의 가로세로비가 요소와 다르다면 이미지를 세로 또는 가로방향으로 잘라내어 빈 공간이 생기지 않도록 설정. contain : 이미지가 잘리거나 찌그러지지 않는 한도 내에서 제일 크게 설정. background-repeat image 대체 텍스트 img 태그의 alt 속성 반드시 명시~ background-image 사용 시 text-indent : -9999px margin collapse 형제 요소 사이에서, margin-top과 margin-bottom이 만나면 큰 값이 작은 값을 덮어씀. 부모 요소의 top(bottom)과 자식요소의 top(bottom)이 만나면 발생. width : min-content linear-gradient 말줄임표 만들기 white-space : nowrap overflow : hidden text-overflow : ellipsis 색상값은 Hexadecimal code로 작성.","link":"/2022/12/24/221223-htmlcss/"},{"title":"CSS 기본값 정리(+ 업데이트 중)","text":"상속되는 속성들 글자와 관련된 속성 뿐!! 글꼴(5가지) line-height font-size font-weight font-family font-style 문자 color text-xxx 등등.. 그 외의 속성들은 강제 속성 inherit을 사용하여 속성값을 상속받을 수 있다. 기본값 정리 width : auto (해당 요소가 어떤 display 속성값을 가지느냐에 따라 다르게 동작함을 이해한다.) inline요소는 컨텐츠의 크기만큼만 가지도록 최대한 작은 값을 가짐. block요소는 부모 요소의 width만큼 최대한 늘어남. (주의) flex item이 되면 해당 item들은 block요소가 되지만, width는 최대한 줄어들으려한다. height : autoheight는 inline이든 width든 컨텐츠의 크기만큼만 가지도록 최대한 줄어들려한다. max-width / max-height : none min-width / min-height : 0 box-sizing : content-box color : inherit 대표적인 inline 요소들 a br button img input label select span ::before, ::after로 만든 가상요소도 inline으로 동작.","link":"/2022/12/24/221224-css-default-value/"},{"title":"221225 TIL 요약","text":"Clone 과제하면서 느꼈던 점 layout은 철저히 계획 하에 하자. 즉, CSS 작업이 들어갈 때 웹 페이지의 layout 박스들이 머릿 속에 그려져야 한다. 그만큼 layout에 대한 계획을 세부적으로 잘 세워놓을 수록 전체 작업 시간이 많이 줄어들고, 머릿속도 간결해짐. html구조는 가능하면 최소화한다. (중첩을 최소화해서 tree구조를 최대한 줄일 수록 좋을 듯하다.) 고려해볼 만한 점 : html구조를 만들지 않고 CSS로 처리할 수 있는 방안이 있는가? (예를 들어 ::before, ::after와 같은 가상 요소) BEM 네이밍 시 하위 구조가 2 depth 이상이 필요하다면, 컴포넌트가 분리되어야 한다는 신호다. (headr__nav__item) 일단 내 clone 과제는 depth가 2,3 이상 필요할 때도 많았고 심지어 내가 BEM을 쓰는 건지 뭘 쓰는건지 이젠 갈피도 못잡겠다. 네이밍 진짜 개어렵다ㅠ 회고 복잡할 수록 구조화하고 구조화 된 틀 안에서 쪼개어 생각하자.","link":"/2022/12/25/221225-css/"}],"tags":[{"name":"error","slug":"error","link":"/tags/error/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"etc","slug":"etc","link":"/tags/etc/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"},{"name":"국비지원교육","slug":"국비지원교육","link":"/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EA%B5%90%EC%9C%A1/"},{"name":"메가바이트스쿨","slug":"메가바이트스쿨","link":"/tags/%EB%A9%94%EA%B0%80%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%8A%A4%EC%BF%A8/"},{"name":"MegabyteSchool","slug":"MegabyteSchool","link":"/tags/MegabyteSchool/"},{"name":"개발자취업부트캠프","slug":"개발자취업부트캠프","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/"},{"name":"내일배움카드","slug":"내일배움카드","link":"/tags/%EB%82%B4%EC%9D%BC%EB%B0%B0%EC%9B%80%EC%B9%B4%EB%93%9C/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"html&#x2F;css","slug":"html-css","link":"/categories/html-css/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"html&#x2F;css","slug":"TIL/html-css","link":"/categories/TIL/html-css/"},{"name":"error","slug":"error","link":"/categories/error/"},{"name":"TIL","slug":"error/TIL","link":"/categories/error/TIL/"}],"pages":[]}