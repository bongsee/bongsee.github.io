{"posts":[{"title":"(Error) git init으로 프로젝트 시작하기 vs git clone으로 프로젝트 시작하기","text":"상황 설명 로컬에서 hexo blog framework로 blog 구축 project를 시작함. github에서 github blog 생성하기 위해 repo 생성. 위의 원격 repo에 hexo-deployer-git plugin을 사용하여 deploy함. hexo project에서 static file들은 public폴더에서 관리하므로, git으로 버전 관리를 하기 위해 public 폴더에 git init 시전. 에러 메세지들 123$ git push origin mainerror: src refspec main does not match anyerror: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git' remote에는 master branch가 없기 때문에 출력된 에러 메세지 123456789$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (fetch first)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. remote에 있는 것들이 당연하게 내 local에도 있어야 하는데, 없으니까 일단 pull로 땡겨와라. 라는 메세지 12345678910$ git pull origin mainremote: Enumerating objects: 46, done.remote: Counting objects: 100% (46/46), done.remote: Compressing objects: 100% (27/27), done.remote: Total 46 (delta 9), reused 46 (delta 9), pack-reused 0Unpacking objects: 100% (46/46), 129.91 KiB | 601.00 KiB/s, done.From https://github.com/bongsee/bongsee.github.io * branch main -&gt; FETCH_HEAD * [new branch] main -&gt; origin/mainfatal: refusing to merge unrelated histories 관련 없는 기록 병합 거부 remote의 commit history와 local의 commit history가 관련성이 없기 때문에 merge하는데 실패하는 것 기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit지점이 존재해야 한다.그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit이 없기때문에 pull 명령어를 사용할 수 없는 것이다. 12345678$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (non-fast-forward)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 힌트 : 현재 지점의 끝이 원격 지점 뒤에 있기 때문에 업데이트가 거부되었습니다. 다시 푸시하기 전에 원격 변경 사항을 통합하십시오. rejected : push가 거부되었다. master -&gt; master : 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 했는데 non-fast-forward : 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다. 라는 의미이다. 그럼 git push는 내부적으로 어떻게 할지말지를 판단하나 ? push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다.그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 정리 애초에 접근부터가 잘못됐다. (git clone)원격 repo에서 프로젝트를 시작했으면, 해당 repo를 clone해와서 repo와 local을 동기화시킨 이후에 작업을 해야하는 것이고, (git init)local에서 프로젝트를 시작했으면, remote에 대한 설정과 upstream 링크를 걸어주는 등의 작업을 직접해야하는 것이다. 결론은 어쨌든 연결되는 공통된 커밋 포인트가 없다는 것. 아~ 최우영 강사님,, 이제야 깨닫습니다. 왜 remote에서 시작해서 clone하는게 편한지요… Refs https://jobc.tistory.com/177","link":"/2022/12/19/221219_error_git/"},{"title":"Data Format에 대해","text":"Data Format (22.12.17)Focus 데이터 포맷이 왜 필요할까 ? JSON YAML 데이터 직렬화/역직렬화 1. 데이터 포맷이 왜 필요할까 ? 혼자 개발하거나, 내부적으로 데이터를 사용할 땐 내부의 규칙을 문서화하고 참고하면 그만이지만, 문제는 타인 또는 타 시스템과 연동을 해야할 때다. 데이터를 주고 받을 때 마다 각자 정해진 규칙을 문서로 주고 받는 것도 비효율적이고, 하나의 통일된 규칙이 없을 때 생기는 불필요한 문서들이 많아지기 마련임. 이렇게 상호가 데이터를 효율적으로 다루고자 통일된 규칙을 가지는 ‘format’이 등장하게 된다. XML, JSON, YAML 등이 있다. 2. JSON JSON 데이터 포맷 예시1234567891011121314151617181920212223242526272829303132{ &quot;name&quot;: &quot;Rust&quot;, &quot;on&quot;: { &quot;push&quot;: { &quot;branches&quot;: [&quot;master&quot;] }, &quot;pull_request&quot;: { &quot;branches&quot;: [&quot;master&quot;] } }, &quot;env&quot;: { &quot;CARGO_TERM_COLOR&quot;: &quot;always&quot; }, &quot;jobs&quot;: { &quot;build&quot;: { &quot;runs-on&quot;: &quot;ubuntu-latest&quot;, &quot;steps&quot;: [ { &quot;uses&quot;: &quot;actions/checkout@v2&quot; }, { &quot;name&quot;: &quot;Build&quot;, &quot;run&quot;: &quot;cargo build --verbose&quot; }, { &quot;name&quot;: &quot;Run tests&quot;, &quot;run&quot;: &quot;cargo test --verbose&quot; } ] } }} 데이터 직렬화에 유리하여 일반적으로 데이터 전송, AJAX 통신 등 API 통신에 주로 사용됨. XML은 헤더와 태그 등으로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 있었던 데 반해 JSON은 나은 가독성, 효율성을 가진다. 주석을 지원하지 않는다. 데이터 타입을 강제하려면 JSON 스키마로 보완해야한다. 3. YAML YAML 데이터 포맷 예시123456789101112131415161718#!syntax yamlname: Ruston: push: branches: [master] pull_request: branches: [master]env: CARGO_TERM_COLOR: alwaysjobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Build run: cargo build --verbose - name: Run tests run: cargo test --verbose​ 주로 수정이 잦은 설정(conf) 파일에 사용됨. XML, JSON 보다 직관적이라 가독성이 좋다. 주석이 가능하다. 데이터 타입을 명시해줄 수 있다. 데이터 직렬화가 불편하다. 4. 데이터 직렬화/역직렬화 : (보완, 수정 요 - 운영체제) 직렬화(Serialization)란, 참조 타입의 데이터를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형태로 변환하는 작업임. 역직렬화(Deserialization)란, 디스크에 저장된 데이터를 읽거나, 네트워크를 통해 전송받은 데이터를 메모리에 저장하기 위한 형태로 변환하는 작업임. 메모리에서 데이터가 가지는 구조는 2가지다. 값(Value) 형식 데이터 참조(Reference) 형식 데이터 : 객체 타입이 여기에 해당. 이 두가지 데이터 중 디스크에 저장하거나 네트워크 통신을 할 수 있는 데이터는 값(Value) 형식의 데이터다. 직렬화를 통해 참조 형태의 데이터를 값 형태로 변환.","link":"/2022/12/19/221218_data_format/"},{"title":"Mark down 문법 정리(+ 업데이트 중)","text":"* 구분선--- * 텍스트 강조**강조될 텍스트** 강조될 텍스트 / 일반 텍스트 * 이미지 삽입![이미지 이름](이미지 주소) * 줄 바꿈엔터 두번 * 줄 여러번 바꾸기&lt;br&gt; 2022-12-24 추가 업데이트Markdown file에서 이미지 크기 조절하기 기존의 이미지 삽입과 다른 방식을 사용. img tag를 활용할 수 있다. &lt;img src=&quot;이미지 주소&quot; width=&quot;원하는 가로너비&quot; height=&quot;원하는 세로너비&quot;&gt; 2022-12-27 추가 업데이트들여쓰기 4개의 공백으로 들여쓰기가 가능하다.","link":"/2022/12/18/221218_markdown/"},{"title":"221219, 221220 TIL (html, css)","text":"박영웅 강사님의 html, css 강의 인상 깊었던 멘트 어떤 사이트를 클론할 땐 가장 먼저 해야할 것은 ‘구조화’이다. 모든 layout은 위에서 아래로 쌓인다. 세세한 수치는 개발자 도구에서 찾아서 쓰기 브라우저가 기본적으로 제공하는 값들이 존재한다. –&gt; 브라우저의 기본 셋팅값을 초기화 시킨 후 진행 css 속성들의 default 값을 먼저 알아라. 내가 직접 지정하지 않아도 설정되어있는 값을 아는 것이 먼저! 그 후에 제대로 된 조작이 가능! ‘검증’에 대한 고찰 어떤 코드를 검증하고자 할 땐 주변 코드를 배제시키고 백지에 검증하고자 하는 코드만 놓고 봐야한다. 그렇지 않으면 주변 코드에 의해 오염될 가능성이 높아지고, 검증의 신뢰도는 급격히 떨어짐. KeywordsHTML html 전역속성 DOCTYPE의 의미 data-xxx 속성 tabIndex, contenteditable 속성 HTML Entity 그럼에도 불구하고 Semantic tag를 지향해야하는 이유 CSS vector image / bitmap image scss / css framework / css in js viewport image sprite CSS 선택자 종류 inline element / block element inline요소는 본질적으로 layout을 다루기 위한 것이 아닌, 글자를 제어하기 위한 용도이다. 따라서 inline 요소는 너비값인 width와 height 속성을 부여해도 동작하지 않는다. width와 height의 default : auto &amp; 그 의미 CSS 선택자 읽는 법 가상 클래스 선택자 / 가상 요소 선택자 CSS 상속 상속이 되는 속성 postion : absolute에 대한 고찰 강제 상속 inherit 선택자 명시도 box-sizing : border-box etc cross browsing Emmet 문법","link":"/2022/12/22/221219-htmlcss/"},{"title":"(프로그래머스 lv0) 두수의 나눗셈 알고리즘 풀이","text":"문제 설명 정수 num1과 num2가 매개변수로 주어질 때, num1을 num2로 나눈 값에 1,000을 곱한 후 정수 부분을 return 하도록 soltuion 함수를 완성해주세요. 제한사항 0 ≤ num1 ≤ 100 0 ≤ num2 ≤ 100 입출력 예 num1 num2 result 3 2 1500 7 3 2333 1 16 62 입출력 예 설명 입출력 #1 : num1이 3, num2가 2이므로 3 / 2 = 1.5에 1,000을 곱하면 1500이 됩니다. 입출력 #2 : num1이 7, num2가 3이므로 7 / 3 = 2.33333…에 1,000을 곱하면 2333.3333…. 이 되며, 정수 부분은 2333입니다. 나의 풀이12345function solution(num1, num2) { let answer = 0; answer = Math.floor((num1 / num2) * 1000); return answer;} 회고 연산자 우선순위를 고려하면 다음의 코드를 수정할 수 있겠다. 곱하기, 나누기, 나머지 연산자는 같은 레벨의 우선순위를 가지며, 좌결합성의 연산자이다. (num1 / num2) * 1000 -&gt; num1 / num2 * 1000 즉, 괄호는 불필요함. 다만, 가독성을 고려하면 개인적으로 전자가 코드의 의도를 읽기 쉬워보임. 연산자 우선순위 ref","link":"/2022/12/22/221221-algo-%EB%91%90%EC%88%98%EC%9D%98%EB%82%98%EB%88%97%EC%85%88/"},{"title":"(프로그래머스 lv0) 분수의 덧셈 알고리즘 풀이","text":"문제 설명 첫 번째 분수의 분자와 분모를 뜻하는 denum1, num1, 두 번째 분수의 분자와 분모를 뜻하는 denum2, num2가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 &lt; denum1, num1, denum2, num2 &lt; 1,000 입출력 예 denum1 num1 denum2 num2 result 1 2 3 4 [5, 4] 9 2 1 3 [29, 6] 입출력 예 설명 입출력 #1 : 1 / 2 + 3 / 4 = 5 / 4입니다. 따라서 [5, 4]를 return 합니다. 입출력 #2 : 9 / 2 + 1 / 3 = 29 / 6입니다. 따라서 [29, 6]을 return 합니다. 나의 풀이1234567891011function solution(denum1, num1, denum2, num2) { let denum = denum1 * num2 + denum2 * num1; // 통분 후의 분자 let num = num1 * num2; // 통분 후의 분모 let divider; // 추가적으로 나눠야 하는가 ? 최대공약수 구하기 for (let i = 1; i &lt;= Math.min(denum, num); i++) { if (denum % i === 0 &amp;&amp; num % i === 0) { divider = i; } } return [denum / divider, num / divider];} 회고 최대공약수라는 개념을 아예 잊고 지냈는데, 다시 만나니까 반갑지 않다.","link":"/2022/12/22/221222-algo-%EB%B6%84%EC%88%98%EC%9D%98%EB%8D%A7%EC%85%88/"},{"title":"(프로그래머스 lv0) 최빈값 구하기 알고리즘 풀이","text":"문제 설명 최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다. 제한사항 0 &lt; array의 길이 &lt; 100 0 ≤ array의 원소 &lt; 1000 입출력 예 array result [1,2,3,3,3,4] 3 [1,1,2,2] -1 [1] 1 입출력 예 설명 입출력 #1 : [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다. 입출력 #2 : [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다. 입출력 #3 : [1]에는 1만 있으므로 최빈값은 1입니다. 나의 풀이12345678910111213141516171819202122232425function solution(array) { let numObj = {}; let max = 0; let answer = -1; // numObj 객체에 배열의 각 요소별 개수 정보를 입력 for (let num of array) { numObj[num] ? (numObj[num] += 1) : (numObj[num] = 1); } // 가장 높은 빈도수를 max에 할당 for (let key in numObj) { max = Math.max(max, numObj[key]); } // max 빈도수를 가진 요소를 출력 for (let key in numObj) { // max 빈도수가 중복이라면 -1 반환 if (numObj[answer] === numObj[key]) { return -1; } // max 빈도수값을 가지는 요소를 반환 if (numObj[key] === max) { answer = parseInt(key); } } return answer;} 회고 객체의 key값은 항상 타입이 문자열임을 잊지말자. 분명 더 쉬운 방법이 있을 것 같은데 다시 한번 들춰봐야할 것 같다.","link":"/2022/12/22/221222-algo-%EC%B5%9C%EB%B9%88%EA%B0%92%EA%B5%AC%ED%95%98%EA%B8%B0/"},{"title":"(프로그래머스 lv0) 옷가게 할인받기 알고리즘 풀이","text":"문제 설명 머쓱이네 옷가게는 10만 원 이상 사면 5%, 30만 원 이상 사면 10%, 50만 원 이상 사면 20%를 할인해줍니다.구매한 옷의 가격 price가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요. 제한사항 10 ≤ price ≤ 1,000,000 price는 10원 단위로(1의 자리가 0) 주어집니다. 소수점 이하를 버린 정수를 return합니다. 입출력 예 price result 150,000 142,500 580,000 464,000 입출력 예 설명 입출력 #1 : 150,000원에서 5%를 할인한 142,500원을 return 합니다. 입출력 #2 : 580,000원에서 20%를 할인한 464,000원을 return 합니다. 나의 풀이1234567891011121314function solution(price) { const level1 = 1 - 0.05; const level2 = 1 - 0.1; const level3 = 1 - 0.2; if (price &gt;= 500_000) { return Math.floor(price * level3); } else if (price &gt;= 300_000) { return Math.floor(price * level2); } else if (price &gt;= 100_000) { return Math.floor(price * level1); } else { return price; }} 회고 조건이 여러개 달리기 때문에 switch문을 사용해보면 어떨까했다. switch문의 case 뒤에 오는 건 조건이 아니라 값이다. 즉, 조건이 와버리면 값으로 평가해버리기 때문에 Boolean 값으로 자동 형변환이 진행된다. 또한 switch문은 기준이 되는 값과 case뒤에 오는 값의 일치여부(일치 연산자 ===)를 보기 때문에 아래의 코드는 내 의도와는 다르게 동작할 수 있다. 1234567891011121314function solution(price) { const level1 = 0.05; const level2 = 0.1; const level3 = 0.2; switch (price) { case price &gt;= 500_000: // &quot;price가 price &gt;= 500_000이라면&quot; 으로 해석이 되는 것이 아니라, 'price &gt;= 500_000'는 Boolean값으로 평가되기 때문에 'price === true라면', 또는 'price === false 라면' 으로 해석되는 것. return price * (1 - level3); case price &gt;= 300_000: return price * (1 - level2); case price &gt;= 100_000: return price * (1 - level1); }} swicth문은 case 뒤에 오는 값을 하나로 특정지을 수 있고, 그 값을 기준값과 비교하려고 할 때 써야할 것 같다. 논외로 switch문 사용하면서 들었던 의문을 정리해본다. 함수 내부의 switch문에서 반복문의 종료로 return을 사용할 수 있다. 다만 break는 switch문만을 탈출하고 함수 내부의 흐름으로 넘어가는 반면, return을 사용할 경우 switch문을 탈출하는 것 뿐 아니라, switch문이 위치해있던 함수도 종료함으로써 함수를 호출했던 context로 실행 흐름이 넘어간다.","link":"/2022/12/24/221224-algo-%EC%98%B7%EA%B0%80%EA%B2%8C%ED%95%A0%EC%9D%B8%EB%B0%9B%EA%B8%B0/"},{"title":"221223 TIL (html, css)","text":"박영웅 강사님의 html, css 강의이 포스트는 heropy blog의 post를 참조합니다. 인상 깊었던 멘트 정렬과 배치는 다른 개념이다. margin : auto는 배치를 하는 것이지 정렬의 개념이 아니라는 것. 명시적 !== 암시적 Flex 요소 Flex Container &amp; Flex item (각각에 적용할 수 있는 속성은 정해져있다.) Flex Container : display, flex-flow(flex-direction + flex-wrap), justify-content, align-content, align-items Flex item : order, align-self, flex(flex-grow, flex-shrink, flex-basis) Flex item 들은 block 요소처럼 동작하지만, 일반적인 block요소와는 다르게 width를 최대한 적게 가져간다. 추가적으로 강사님 블로그인 heropy blog에서 관련 공부 중에 display : flex와 display : inline-flex의 차이를 보여주는 그림에서 flex container와 flex item를 이해하는데 도움이 될 것 같은 그림을 퍼왔다. main axix &amp; cross axis / 시작점(start), 끝점(end) flex-direction에 따라 변화(상대적인 개념) 개별속성과 단축속성 간혹 단축속성에서 default값이 변화하는 부분이 발생하므로 주의하도록. 가급적 개별속성을 쓰는게 좋아보인다. Flex container의 정렬 속성에서 사용되는 단어의 의미 파헤치기 justify : main axis에 적용되는 정렬 align : cross axis에 적용되는 정렬 content : axis에 존재하는 줄이 여러개일 때 줄들 사이의 규칙을 적용할 때 사용. (2줄 이상) 예를 들어, flex container의 flex-direction이 row(default)일 때, flex-wrap : wrap 속성이 없다면 align-content 속성이 적용 안된다. (한 줄이기 때문에) items : axis에 존재하는 각각의 줄에 적용 (개별적용) space-xxx : 남는 공간/공백(space)를 어떻게 활용할 것 인가? 에 대한 속성 flex item의 정렬 속성에서 flex 속성 파헤치기 (item의 너비에 관한 속성)괄호 안은 해당 속성이 가지는 default 값 입니다. (default) flex item들은 한 줄 안에 모두 들어가려함. (flex-wrap : nowrap;) flex-grow (0) : item의 증가 너비 비율을 지정 (여기서 증가하는 부분은 main-axis방향으로, flex-direction에 따라 width가 될 수도, height가 될 수도.) flex-shrink (1) : item의 감소 너비 비율을 지정 (마찬가지.) flex-basis (auto) : item의 기본 너비 설정 auto : item의 content 너비를 제거한 공백 기준으로 계산 0 : content 너비를 포함한 계산 (우리가 보통 상상하는 그림이 이 값을 통해 나옴.) (주의)단축 속성으로 사용시 flex-basis의 default 값이 0으로 변화 Positionposition : static position의 기본값. position : absolute 적용된 요소는 자동으로 block요소로 동작한다. 주변과의 상호작용이 끊김. 위치 상의 부모를 찾는다. (없다면 viewport를 기준으로 동작) 위치 상의 부모를 지정해주기 위해 position : relative를 조상 요소 중 하나에 적용시킨다. (가급적 가까운 부모에 해주기) position : fixed 적용된 요소는 자동으로 block요소로 동작한다. 주변과의 상호작용이 끊김. viewport 기준으로 동작 (주의) transform, perspective, filter 의 속성 중 하나가 조상 요소 중에 적용이 되어있다면 해당 요소를 기준으로 동작함. 외울 필요는 없어보이고, fixed가 내 예상과는 달리 동작한다면 해당 케이스를 의심해볼 정도면 될 것으로 보인다. position : relative 자기 자신을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용 그러나, 위의 목적으로 쓰기에는 layout 해석 및 코드 유지보수의 관점에서 매우 불리해진다. relative는 주변과의 상호작용은 유지되면서 시각적으로 렌더링되는 위치만 옮겨지는 것이기 때문. (박영웅 강사님의 택배박스 neck slice 예시) transform : translate()으로 대체 가능. 그럼 어디에 쓰느냐 ? position : absolute가 적용된 요소의 기준점을 설정할 때 사용. position : sticky top, right, bottom, left의 값 중 하나 이상 적용이 되어야 동작한다. ETCbackground-image 속성 background-image : url() background-size : cover / contain cover : 이미지가 찌그러지지 않는 한도 내에서 제일 크게 설정. 이미지의 가로세로비가 요소와 다르다면 이미지를 세로 또는 가로방향으로 잘라내어 빈 공간이 생기지 않도록 설정. contain : 이미지가 잘리거나 찌그러지지 않는 한도 내에서 제일 크게 설정. background-repeat image 대체 텍스트 img 태그의 alt 속성 반드시 명시~ background-image 사용 시 text-indent : -9999px margin collapse 형제 요소 사이에서, margin-top과 margin-bottom이 만나면 큰 값이 작은 값을 덮어씀. 부모 요소의 top(bottom)과 자식요소의 top(bottom)이 만나면 발생. width : min-content linear-gradient 말줄임표 만들기 white-space : nowrap overflow : hidden text-overflow : ellipsis 색상값은 Hexadecimal code로 작성.","link":"/2022/12/24/221223-htmlcss/"},{"title":"CSS 기본값 정리(+ 업데이트 중)","text":"상속되는 속성들 글자와 관련된 속성 뿐!! 글꼴(5가지) line-height font-size font-weight font-family font-style 문자 color text-xxx 등등.. 그 외의 속성들은 강제 속성 inherit을 사용하여 속성값을 상속받을 수 있다. 기본값 정리 width : auto (해당 요소가 어떤 display 속성값을 가지느냐에 따라 다르게 동작함을 이해한다.) inline요소는 컨텐츠의 크기만큼만 가지도록 최대한 작은 값을 가짐. block요소는 부모 요소의 width만큼 최대한 늘어남. (주의) flex item이 되면 해당 item들은 block요소가 되지만, width는 최대한 줄어들으려한다. height : autoheight는 inline이든 width든 컨텐츠의 크기만큼만 가지도록 최대한 줄어들려한다. max-width / max-height : none min-width / min-height : 0 box-sizing : content-box color : inherit 대표적인 inline 요소들 a br button img input label select span ::before, ::after로 만든 가상요소도 inline으로 동작.","link":"/2022/12/24/221224-css-default-value/"},{"title":"221225 TIL 요약","text":"Clone 과제하면서 느꼈던 점 layout은 철저히 계획 하에 하자. 즉, CSS 작업이 들어갈 때 웹 페이지의 layout 박스들이 머릿 속에 그려져야 한다. 그만큼 layout에 대한 계획을 세부적으로 잘 세워놓을 수록 전체 작업 시간이 많이 줄어들고, 머릿속도 간결해짐. html구조는 가능하면 최소화한다. (중첩을 최소화해서 tree구조를 최대한 줄일 수록 좋을 듯하다.) 고려해볼 만한 점 : html구조를 만들지 않고 CSS로 처리할 수 있는 방안이 있는가? (예를 들어 ::before, ::after와 같은 가상 요소) BEM 네이밍 시 하위 구조가 2 depth 이상이 필요하다면, 컴포넌트가 분리되어야 한다는 신호다. (headr__nav__item) 일단 내 clone 과제는 depth가 2,3 이상 필요할 때도 많았고 심지어 내가 BEM을 쓰는 건지 뭘 쓰는건지 이젠 갈피도 못잡겠다. 네이밍 진짜 개어렵다ㅠ 회고 복잡할 수록 구조화하고 구조화 된 틀 안에서 쪼개어 생각하자.","link":"/2022/12/25/221225-css/"},{"title":"22년 12월 5주차 주간 회고","text":"주간 회고 한 주간 배운점, 느낀점, 보완해야할 점을 keyword 중심으로 나열합니다. 배운점 CSS CSS를 바라보는 틀을 잡다. CSS는 크게 Layout을 잡는 속성과 그 외의 속성으로 바라볼 수 있다. 예를 들어, layout을 잡는 용도의 block요소와 글자를 다루기 위한 inline요소가 있겠다. CSS의 각 속성은 default값이 무엇인가?부터 시작한다. 내가 명시적으로 지정하지 않아도 암묵적으로 적용되고 있는 속성들이 존재한다는 것을 안다. 검증이 필요할 땐 백지에서 시작한다. 주변의 코드로부터 오염되는 것을 방지하기 위해. CSS 선택자를 읽고 해석하는 방법 CSS는 웹 표준으로, legacycode가 잔존한다는 것을 이해한다. 상속이 되는 속성은 정해져있다. 개별속성과 단축속성 속성값이 절대적인 값인가? 혹은, 기준이 필요한 상대적인 값인가? 배치와 정렬이 다름을 인지. position … 주변과의 상호작용이 끊기는가 ? 반응형 breakpoint에 따라 매번 새로 만드는 개념이 아님. 시안을 보고 가변적으로 동작하는 요소로 가능하다면 굳이 새로 모양을 잡을 필요가 없는 것. UI Framework에 대한 생각 쓸 때 좋을지, 아니면 유지보수를 최대한 고려할 지. 심사 숙고하여 도입하기 느낀점 이번 한 주는 1차 과제(웹페이지 클론코딩)을 하는데 전부를 보낸 것 같다. 우선 클론코딩하면서 지나갔던 생각들을 여기에 잡아놓아본다. 우선, layout에 관한 이야기다. section별로 layout을 잡고 코딩을 시작했는데, 어느 section은 layout을 가장 큰 단위로만 잡고 바로 코드를 짰고, 어느 section은 layout을 가장 최하위까지 구조화해서 들어갔다. 전자의 경우 코드를 짜다가 중간에 html구조를 추가하는 일이 빈번하게 발생했고, 그에 따라 CSS code 구조도 매번 새롭게 다시 짜야했기 때문에 시간은 시간대로 들이고, 머릿속은 그것대로 복잡해졌다. 결국 어찌저찌 구현은 했는데 기분은 마치 똥싸고 똥꼬 안닦은 느낌과 비슷했다. 일처리가 매끄럽지 못했기 때문이라고 생각한다. 후자의 경우 최대한 layout을 최하위까지 잡고 들어갔다. 그렇게 했더니 구조화된 틀 안에서 컴포넌트 별로 분리해서 생각할 수 있었고, 오히려 처음에 잡은 구조는 조금 더 복잡했지만(최하위 요소까지 고려해야했기 때문에) 머릿속은 한결 가벼웠고 결과적으로 쏟아 부은 시간도 적게 들었다. 또한 막히는 부분이 생기면, 어떻게 구현을 할 수 있을까? 또는 현재 구조에서 구현이 불가능하다면 layout에서 어떤 부분의 설계가 잘못되었는가? 와 같은 좀 더 발전적인 질문까지 던질 수 있었다. 결론은, 후자의 경우가 처음엔 느려보일지라도 결과적으로 훨씬 나은 선택일 수 있다는 것. layout에 대한 설계에 가장 많은 시간을 쏟아내자는 것이다. 흘러가는 지식들이 너무 많다. 배운 내용을 그때 그때 정리하는 편이다. 그러나 다시 들춰보지를 않으니 동일한 문제를 만날 때마다 검색하고 하는 일이 너무 빈번한 것 같다. 배운 내용을 정리하는 건 내 작업기억에만 머물뿐이다. 당장 오늘 배운 내용을 머릿속에 집어넣는 것도 중요하지만, 들어왔던 지식이 도망가지 않게 붙잡아 두는 것이 더 중요하다. 중요도를 따지자면 3:7정도 ? 복습을 좀 잘해보자. 그러기 위해선 keyword를 그날 그날 잘 정리해 두는 것이 굉장히 중요해보인다. 보완해야할 점 블로그에 내가 배웠고 느꼈던 점들을 포스팅하고 있는데, 포스팅 규칙이 정해져있지 않아서 블로그 가독성도 많이 떨어져 보이고, 원래 내 목적이었던 한달 뒤에도 들춰볼 수 있는 블로그 만들기 가 한달 뒤에 도대체 어디서부터 뭘 봐야하는가 로 바뀔 우려가 있어보인다. 주말을 이용해서 간단하게 포스팅 규칙을 정해보도록 하자.","link":"/2022/12/27/wil-2212-5th/"},{"title":"TIL 221226 transition, animation, responsive","text":"transtion transition을 왜 쓰는가? transition속성을 요소의 ‘전’ 상태에 선언해야하는 이유. transition의 개별 속성과 기본값 animation animation을 왜 쓰는가? animation의 개별 속성과 기본값 animation의 at-rules(@) responsive (media) media 는 언제 쓰이나 ? media의 at-rules(@) media type의 기본값 === all (굳이 명시? 생략하련다) media query max-width와 min-width의 의미 현업에서 반응형을 짜는 flow 요소를 가변적으로 만들면 해결이 되는가 ?","link":"/2022/12/27/til-221226-css/"},{"title":"TIL 221227 CSS Grid","text":"Grid System grid-template-xxx 와 grid-auto-xxx에서 template , auto가 가지는 의미 grid 속성값에서 span이 가지는 의미 Track, Line(=gutter), Cell ,Area fraction =&gt; fr grid-auto-flow CSS 기타 css를 html구조의 순서에 맞게 짜는게 중요한 이유 ‘배치’ 라는 것은 다른 요소와 겹칠 수 있는 가능성이 있다 라는 것 z-index는 기본적으로 자신의 position 값이 static 이외의 다른 값을 가질 때 지정가능. 위의 기본적인 사항 이외에 flex container나 grid container 내부의 자식에 z-index를 설정할 수 있는 등 예외적인 사항이 몇 가지 있는 것으로 보이나, 실제로 이렇게 쓰일지는 의문. 기본값 z-index : auto; 부모 요소를 물려받음. span 태그 안에 div 넣기 ? 불가능 a 태그 안에 div 넣기? 하나까지 가능 … 그 이유 ? 화면에 나중에 그려지는게 먼저 그려진거 위에 그려질 수 밖에.","link":"/2022/12/27/til-221227-css/"},{"title":"CSS BEM 방법론 (조금 더 연습이 필요 ++)","text":"BEM 방법론Block, Element, Modifier 장점 클래스 네임만으로 마크업 구조를 알 수 있다. 클래스 네임 자체에 구조적 의미가 담겨있기 때문에 CSS 속성 지정 시 셀렉팅을 늘어지게 할 필요가 없다. SCSS에서 Nesting 구조를 만들 때 더욱 효과적! Block (독립성) 독립적으로 쓰일 수 있고, 다른 곳에 재사용이 되겠는가? block 끼리는 Nesting해서 쓰지 않음. Element (의존성) Block 내에서만 의미를 가짐. 따로 떼어다 다른 곳에서 사용 X Modifier 다르게 동작하거나, 생긴게 약간 다르거나. 약간의 속성 변화를 관리","link":"/2022/12/30/221230-css-bem/"},{"title":"CSS Selector","text":"CSS Selector에 대해 알아보자.(내용 빈약 주의)Keywords기본 선택자 전체 선택자 (*) tag 선택자 class 선택자 id 선택자 복합 선택자 일치 선택자 : 서로 다른 선택자를 붙여 쓰기 자식(직계) 선택자 : &gt; 하위(후손) 선택자 : 띄어쓰기 인접 형제 선택자 : + ABC + XYZ : ABC의 다음 형제 요소 XYZ 하나를 선택 일반 형제 선택자 : ~ ABC ~ XYZ : ABC의 다음 형제 요소 중 XYZ 모두를 선택 가상 클래스 선택자 : 사용자가 어떤 행동을 했을 때 hover, focus, active … cf) focus가 될 수 있는 요소 : 뭘까~요? 1) focus가 될 수 없는 요소지만 ? 속성을 부여하면 focus가 된다 ! 2) 선택자에 조건을 붙일 때 :first-child, :last-child :nth-child(n) :not() 전체 선택자 *(애스터리스크)와 함께라면 굉장히 유용 ! *:nth-child() *:not() 가상 요소 선택자 :: HTML 구조에 가상 요소를 삽입할 때 HTML 요소를 추가하지 않고 CSS선에서 끝내므로 구조적으로 훨씬 간단해질 수 있는 아주 유용한 아이! ::before , ::after 선택된 HTML 요소의 맨 앞 또는 맨 뒤에 삽입. 가상 요소는 inline 요소. content : “” 필수 속성 선택자 [] [ABC] : 단순 속성을 선택할 때 [ABC=&quot;XYZ&quot;] : [type=&quot;password&quot;] 처럼 프로퍼티가 여러 값을 가질 때 정답 HTML 대화형 콘텐츠 input, a, button, label, select … tabindex 순서값으로 -1이 아닌 값을 넣으면 논리적 흐름을 방해하므로, -1을 권장.","link":"/2022/12/30/221228-css-selector/"},{"title":"CSS width &#x2F; height 속성의 동작.","text":"맨날 헷갈리는 width와 height에 대하여!작동 방식 width와 height 모두 기본값은 auto로 설정되어있다. 그럼 auto가 가지는 의미가 뭘까? 브라우저가 알아서 계산하겠다 이거임. 그럼 브라우저는 뭘 기준으로 계산하는데 ? 해당 요소의 display 속성을 기준으로 계산하는 방식을 다르게 가져감. inline 요소는 애초에 layout을 다루기 위해 태어난 것이 아니라 width, height 값을 content요소의 크기만큼 (이 말은 최대한 쪼금만 차지하겠다 이거.) 가져간다. block 요소의 width는 최대한 넓게(부모의 width가 있다면 그만큼까지), height는 최대한 적게 가져간다. flexible box flex container는 block으로 동작. (display : inline-flex으로 다르게 동작시킬 수 있다.) (flex-direction : row일 경우) flex item들은 기본적으로 width를 콘텐츠 영역만큼(즉, 최소한으로)만 가져감. 정렬은 콘텐츠들과 남는 공간(여백)을 가지고 다룰 수 있기 때문에, 반대로 생각해서 여백없이 width를 최대한으로 가져가버리면 정렬이란걸 할 수 없게 된다. align-items : stretch, align-content : stretch 기본값이 최대한 늘어나는 것이라 height에 따로 지정한 값이 없다면(즉, height : auto) height는 쭉쭉 늘어남. max-width / min-width max-width : 요소가 늘어날 수 있는 한계를 지정 min-width : 요소가 줄어들 수 있는 한계를 지정 flexible box를 다룰 때 flex-grow, flex-shrink와 함께 요긴하게 쓰일 듯. box-sizing 기본값 : content-box 요소의 content 크기로 width와 height를 맞추겠다. border-box : 요소의 content 크기 + padding 값 + border-width 값을 모두 더한 값으로 width와 height를 맞추겠다.","link":"/2022/12/30/221229-css-width/"},{"title":"CSS 보이지 않는 것에 대한 정리.","text":"display : none / visibility : hidden / opacity : 0 / color : transparentdisplay : none 해당 요소를 레이아웃에서 아예 빼버림. 마치 그 요소가 원래 없었던 것처럼 동작하지요. DOM 이벤트 발생 X tab focus X visibility : hidden 레이아웃에 요소는 그대로 존재하나, 다만 우리 눈에 보이지 않게 렌더링 할 뿐이다. (투명 인간느낌 ㅇㅇ) DOM 이벤트 발생 X (오우 이건 좀 헷갈릴 수 있겠는데.. codepen에서 실제로 적용해보니 이벤트 발생하지 않는다.) tab focus X 뒤 요소 클릭 가능. opacity : 0 0(완전 투명), 1(완전 불투명) ,, 즉 불투명도를 조절함. 레이아웃에 존재. DOM 이벤트 발생. tab focus O 뒤 요소 클릭 불가능. color : transparent opacity : 0를 사용하면 요소가 통짜바리로 불투명도가 조절되니까 글자만 냅다 패고 싶을 때 사용하자. 또는 rgba(0,0,0,0.4) 를 사용하기. 정리 레이아웃에서 아예 빼고 싶으면 display : none 레이아웃에 그대로 차지하게 두고, 이외 상호작용에서 빼버리고 싶으면 visibility : none 그냥 다 되는데 안보이게만 하고 싶으면 opacity : 0 안보이게 할 건데 글자만 패고싶으면 color : transparent 또는 rgba(0,0,0,0)","link":"/2022/12/30/221229-css-cantsee/"},{"title":"CSS 배경과 이미지에 관하여","text":"CSS에서 배경과 이미지에 관하여 정리배경 (background)background 속성들 background-color 요소의 배경색을 입힘. 기본값 : transparent background-image : 요소의 배경에 이미지를 렌더링 입히고자 하는 이미지의 경로를 url() 함수의 인자로 넣어준다. 아무런 설정값 없이 이미지를 넣게 되면 요소 안에 이미지 파일이 가지는 실제 크기가 렌더링 됨. background-repeat 이미지가 요소 안에서 반복적으로 출력되게 할 것인지를 지정. 기본값 : repeat , 이미지가 최대한 담길 수 있는 한도 내에서 반복적으로 출력됨. repeat-x / repeat-y / no-repeat의 값으로도 설정할 수 있고, 보통은 no-repeat을 자주 사용하게 될 것 같다. background-position 기본값 : 0% 0% 단위 지정 (축 평행 이동) %지정과 px지정의 작동 방식이 약간 다름. 음수%가 양수px처럼 동작. (결론은 두 단위모두 초기 상태에서 x축, y축으로 얼마만큼 평행이동하여 위치시킬지 지정.) 기준 구역 지정 : top, bottom, left, right, center 정방형 9구역 중 어느 영역을 기준으로 이미지를 위치시킬지 지정(지정된 구역을 기준으로 핀 고정한 게 가장 정확한 듯.) background-size 기본값 : auto (이미지의 실제 크기로 브라우저가 알아서 렌더링) 단위 지정 : 가로 세로 지정해서 넣는데 보통 가로 하나만 넣으면 브라우저가 알아서 원본 비율을 유지하여 세로너비를 지정. cover : 배경이미지가 잘리더라도 요소의 배경에 빈 곳 없이 꽉 차도록 한다. (요소의 긴 너비을 기준으로 비율을 유지) contain : 요소의 배경에 빈 곳이 생기더라도 이미지가 모두 출력되도록 한다. (요소의 짧은 너비을 기준으로 비율을 유지) background-attachment 요소의 배경 이미지 스크롤 특성을 지정한다. 기본값 : scroll (이미지가 html 요소를 따라서 스크롤 됨. 우리가 허구헌날 보는 방식이 요거라 생각하면 됨.) fixed : 이미지가 뷰포트 (화면 렌더링 영역) 에 고정됨. 마치 스크롤 하는데 컨텐츠는 스크롤링되어 딸려올라가거나 내려오는데 배경 이미지는 화면에 그대로 고정되어 있는 느낌. 기타 background-color와 background-image의 쌓임 맥락 : 배경색 위에 이미지가 쌓인다고 보면 됨. 그렇다면 background-image와 &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt;를 언제 어떻게 선택하여 사용할까 ?(배경으로서의 사진을 이용하는 경우가 아니라 단순 사진을 삽입하는 경우에 따져보기) 업데이트 주기 업데이트가 짧다 ? img 태그 쓰기. 이유는 간단하다. 둘의 차이는 html의 src 속성으로 경로를 지정하느냐, css의 속성값으로 url 함수의 인자로 경로를 지정하느냐. 백단에서 css의 속성값에 접근하여 바꿀 방법이 없다고 한다. 그러니 업데이트를 자주할 것 같은 이미지는 img태그의 src 속성을 통하여 지정해주도록 하자. 그럼 업데이트가 자주있는 경우엔 무조건 background-size나 background-position 같은 유용한 속성을 포기해야하느냐? 방법이 있긴하다. 바로 html에서 style 전역속성을 사용하여 인라인 스타일로 background 속성을 주는 것. 이렇게 되면 백단에서 경로값을 가져와서 수정할 수 있다. object-fit, object-position으로 background-size, background-position을 대체할 수 있다.","link":"/2023/01/01/221231-css-background/"},{"title":"패스트캠퍼스 프론트엔드 개발과정 4기 1차 과제 회고","text":"패스트캠퍼스 프론트엔드 개발과정 4기 1차 과제(클론코딩) 회고","link":"/2022/12/31/221230-fastcampus-1st-proj/"},{"title":"TIL 230101 (CSS)","text":"230101 오늘의 학습position position은 배치다. position : absolute 또는 postion : fixed 적용 시 해당 요소는 display : block 이 자동으로 적용됨. 쌓임 맥락 요소에 position 속성이 지정되어 있나 ? (static 제외) 1번 만족, z-index 속성의 값이 클 수록 위에 쌓임. 1,2번 조건이 모두 동일할 시, HTML구조 상 나중의 것이 위에 쌓임. z-index의 기본값은 auto이다. (부모의 것을 상속받음.) flex flex container는 block으로 동작. (display : inline-flex으로 다르게 동작시킬 수 있다.) (flex-direction : row일 경우) flex item들은 기본적으로 width를 콘텐츠 영역만큼(즉, 최소한으로)만 가져감. 정렬은 콘텐츠들과 남는 공간(여백)을 가지고 다룰 수 있기 때문에, 반대로 생각해서 여백없이 width를 최대한으로 가져가버리면 정렬이란걸 할 수 없게 된다. align-items : stretch, align-content : stretch 기본값이 최대한 늘어나는 것이라 height에 따로 지정한 값이 없다면(즉, height : auto) height는 쭉쭉 늘어남.","link":"/2023/01/02/til-230101-css/"},{"title":"데이터 타입이 필요한 이유","text":"데이터 타입이 필요한 이유가 뭘까요Modern Javascript Deep Dive의 내용을 요약했습니다. 값은 메모리에 저장하고 참조할 수 있어야한다. 값을 저장할 경우 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야한다. 다시 말해, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실없이 값을 저장할 수 있는지 알아야 한다. 자바스크립트 엔진은 데이터의 타입에 따라 정해진 크기의 메모리 공간을 확보한다. 값을 참조하는 경우 예를 들어, score라는 변수에 숫자 100이라는 값이 저장되어있는 경우, 식별자 score를 통해 숫자 값 100이 저장되어있는 메모리 공간의 선두 메모리 셀의 주소를 찾아간다. 이때 값을 정상적으로 참조하려면 한번에 읽어들여야할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야한다. 그렇게 하지 못하면 값이 훼손될 가능성이 있다. 자바스크립트 엔진은 score 변수에 저장된 값을 숫자 타입으로 인식하고, 숫자 타입은 8바이트의 고정단위로 저장되므로 8바이트 단위로 읽어들인다. 메모리에서 읽어들인 값의 해석 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만, 문자열로 해석하면 ‘A’이다. 정리 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어들인 2진수를 어떻게 해석해야할지 결정하기 위해 ECMAScript 사양에서는 문자열과 숫자타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지 않다. 따라서 문자열과 숫자 타입 외의 데이터 타입은 확보되는 메모리 공간의 크기가 자바스크립트 엔진 제조사의 구현에 따라 다를 수 있다.","link":"/2023/01/02/230102-js-data-type/"},{"title":"Javascript NaN 에 관하여","text":"NaN (Not A Number) 프로그래머스 입문 숨어있는 숫자의 덧셈(1) 문제를 풀며 들었던 의문과 함께 정리해본다. 숨어있는 숫자의 덧셈(1) 문제 설명 문제 설명 문자열 my_string이 매개변수로 주어집니다. my_string안의 모든 자연수들의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 my_string은 소문자, 대문자 그리고 한자리 자연수로만 구성되어있습니다. 입출력 예 my_string result “aAb1B2cC34oOp” 10 “1a2b3c4d123” 16 입출력 예 설명 입출력 예 #1 : “aAb1B2cC34oOp”안의 한자리 자연수는 1, 2, 3, 4 입니다. 따라서 1 + 2 + 3 + 4 = 10 을 return합니다. 입출력 예 #2 : “1a2b3c4d123Z”안의 한자리 자연수는 1, 2, 3, 4, 1, 2, 3 입니다. 따라서 1 + 2 + 3 + 4 + 1 + 2 + 3 = 16 을 return합니다. 유의사항 연속된 숫자도 각각 한 자리 숫자로 취급합니다. 최종 풀이 12345678910function solution(my_string) { const my_string_arr = Array.from(my_string); let answer = 0; my_string_arr.forEach((element) =&gt; { if (!isNaN(element)) { answer += Number(element); } }); return answer;} NaN이란 ? NaN은 Not A Number 즉, 숫자가 아니라는 의미의 숫자 타입의 데이터이며, 전역 객체의 속성이다. (실제로 브라우저환경이나, Node.js환경에서 전역 객체를 찍어보면, 내부에 NaN이 들어있다.) NaN을 반환하는 연산 다섯가지 숫자로서 읽을 수 없음 (parseInt(“어쩌구”), Number(undefined)) 결과가 허수인 수학 계산식 (Math.sqrt(-1)) 피연산자가 NaN (7 ** NaN) 정의할 수 없는 계산식 (0 * Infinity) 문자열을 포함하면서 덧셈이 아닌 계산식 (“가” / 3) NaN 판별법 NaN의 판별 Number.isNaN() 또는 isNaN() 을 이용. isNaN()과 Number.isNaN()의 차이를 주의. isNaN은 현재 값이 NaN이거나, 숫자로 변환했을 때 NaN이 되면 참을 반환하지만, Number.isNaN은 현재 값이 NaN이어야만 참을 반환. 자기 자신과 같지 않음을 이용12345function valueIsNaN(v) { return v !== v;}valueIsNaN(1); // falsevalueIsNaN(NaN); // true (주의) 일부 배열 메서드는 NaN을 찾을 수 없다.1234let arr = [2, 4, NaN, 12];arr.indexOf(NaN); // -1 (false)arr.includes(NaN); // truearr.findIndex((n) =&gt; Number.isNaN(n)); // 2","link":"/2023/01/02/230102-js-NaN/"},{"title":"전역 변수의 문제점과 억제 방안","text":"","link":"/2023/01/02/230102-js-global-variable/"},{"title":"TIL 230102 javascript","text":"2차 과제 (영화 검색 api 만들기) preview과제 상세 내용 Client의 요청과 Server 측에서의 인증, apikey, feat.queryString 프론트단에서 만들어진 코드를 숨기는 것은 불가능함. Serverless function을 이용한 data 은닉? how ? keydown 이벤트와 isComposing 프로퍼티 한글 사용 시 발생되는 문제(이벤트 두번 호출)를 방지.","link":"/2023/01/02/til-230102-js/"},{"title":"23년 1월 1주차 주간회고","text":"주간 회고 (22.12.29 ~ 23.01.04) 한 주간 배운점, 느낀점, 보완해야할 점을 keyword 중심으로 나열합니다. 배운점 CSS display : none, visibility : hidden, opacity : 0, color : transparent 의 차이점 키워드 : 레이아웃, 이벤트 발생, focus, 뒷 요소 클릭 여부 관련 포스팅 보러가기 width와 height의 작동 방식 키워드 : 기본값, display 속성 관련 포스팅 보러가기 BEM 방법론 키워드 : 아직도 헤메는 중이다. 관련 포스팅 보러가기 background 키워드 : background-size, background-image, background-position, background-repeat, background-attatchment , background-image와 img태그 관련 포스팅 보러가기 position 키워드 : 배치, 쌓임 맥락 조건, display : block 자동 적용 관련 포스팅 보러가기 Javascript 데이터 타입의 필요성 키워드 : 값, 저장, 참조, 해석, 메모리 효율 관련 포스팅 보러가기 NaN 키워드 : 일치 연산자, 데이터 타입, NaN의 판별법과 각 방법의 차이 / 주의점 관련 포스팅 보러가기 느낀점 2차과제가 시작되면서 Javascript로 기능을 구현할 기회도 생겼다. 기능을 구현하는데 여러가지 변수도 선언하고, 함수도 선언하면서 코드를 짰다. 그러나 그러한 식별자들은 기능 구현을 위해 즉흥적으로 만드는 경우가 많았다.즉, 내가 이 식별자를 어떻게 관리할 수 있고, 또 어느 스코프에서만 유효하고, 이 식별자를 다른 상황에서 어떻게 쓰일 수 있는지 등등 제대로 알지 못한채 무분별하게 선언한 것들이 많았다. 그렇다 보니 코드가 비효율적이며 가독성도 많이 떨어졌고 결과적으로 프로젝트가 점점 산으로 간다는 것을 느꼈다. 기능 하나를 구현하기 위해선 순서도를 쓸 필요가 있다고 느껴졌다. 또한, 식별자는 최대한 내 구상 하에 선언을 해야겠다고 생각이 들었다.모든 가능성을 열어두고 순서도를 치밀하게 작성하는 연습을 해야겠다. 변수 또한 신중하게 선언하도록 노력하고, 최대한 전역 변수를 사용하지 않는 선에서 사용해야겠다. 보완해야할 점 복잡한 로직을 만날 때 마다 자꾸 머릿속이 복잡해지고 코드에 내 머릿속의 복잡함이 그대로 묻어난다. 머릿속에서 상상하지말고 순서도를 그리며 시각화하는 연습을 합시다. 또한, 복잡하다면 단순화해서 생각해보는 연습도 좋을 것 같다. javascript code에서 Javascript Data 가공과 HTML/CSS 렌더링은 구분해서 생각하기. + 코드도 분리해서 작성하기 프로젝트 진행 사항을 기록하고 관리하는 문서를 작성하기. 순서도를 짜고 구상하는데 가장 많은 시간을 할애하기.","link":"/2023/01/04/wil-2301-1st/"},{"title":"(프로그래머스 lv0) 삼각형의 완성 조건 (1)","text":"문제 설명 선분 세 개로 삼각형을 만들기 위해서는 다음과 같은 조건을 만족해야 합니다. 가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 합니다. 삼각형의 세 변의 길이가 담긴 배열 sides이 매개변수로 주어집니다. 세 변으로 삼각형을 만들 수 있다면 1, 만들 수 없다면 2를 return하도록 solution 함수를 완성해주세요. 제한사항 sides의 원소는 자연수입니다. sides의 길이는 3입니다. 1 ≤ sides의 원소 ≤ 1,000 입출력 예 sides result [1, 2, 3] 2 [3, 6, 2] 2 [199, 72, 222] 1 입출력 예 설명 입출력 예 #1 : 가장 큰 변인 3이 나머지 두 변의 합 3과 같으므로 삼각형을 완성할 수 없습니다. 따라서 2를 return합니다. 입출력 예 #2 : 가장 큰 변인 6이 나머지 두 변의 합 5보다 크므로 삼각형을 완성할 수 없습니다. 따라서 2를 return합니다. 입출력 예 #3 : 가장 큰 변인 222가 나머지 두 변의 합 271보다 작으므로 삼각형을 완성할 수 있습니다. 따라서 1을 return합니다. 나의 풀이12345function solution(sides) { const max = Math.max(...sides); const sum = sides.reduce((acc, cur) =&gt; acc + cur); return sum - max &gt; max ? 1 : 2;} 회고 볼 때마다 헷갈리는 reduce 메소드를 간단하게 정리해봅니다. reduce 메서드는 두 개의 인자를 받는다. 콜백함수(reducer함수) initialValue reducer 함수는 다시 네 개의 인자를 받는다 accumulator currentValue currentIndex 원본 배열 reduce 메서드에 initialValue 인자를 따로 넘겨주지 않으면, accumulator에는 배열의 첫번째 요소가 들어간다. 자동으로 currentValue는 두번째 요소부터 시작되게 된다. accumulator는 콜백함수(reducer함수)의 return값을 누적한다. reduce메서드의 최종 반환값은 콜백함수의 모든 return값이 누적되어있는 accumulator의 값을 반환한다. (한마디로 누적값을 반환.) 빈 배열에 reduce 메서드를 호출 시 반드시 initialValue를 추가 인자로 제공해야한다. (안할 시 TypeError 발생) 예제 출처 객체의 프로퍼티를 기준으로 객체를 분류하기. 1234567891011121314151617181920const people = [ { name: &quot;Anna&quot;, isMajor: true }, { name: &quot;Bob&quot;, isMajor: true }, { name: &quot;Alice&quot;, isMajor: false }, { name: &quot;David&quot;, isMajor: false }, { name: &quot;Chris&quot;, isMajor: true },];function groupBy(objArr, criteria) { return objArr.reduce((acc, obj) =&gt; { const key = obj[criteria]; if (!acc[key]) { acc[key] = []; } acc[key].push(obj); return acc; }, {});}const isMajor = groupBy(people, &quot;isMajor&quot;);console.log(isMajor); 스프레드 구문과 객체로 이루어진 배열에 담긴 배열 연결 12345678910111213141516171819202122232425const friends = [ { name: &quot;Anna&quot;, books: [&quot;Modern JS Deep Dive&quot;], age: 21, }, { name: &quot;Bob&quot;, books: [&quot;Core JS&quot;, &quot;Do you know JS ?&quot;], age: 26, }, { name: &quot;Alice&quot;, books: [&quot;Clean Code&quot;, &quot;Clean Architecture&quot;], age: 18, },];const allbooks = friends.reduce( (acc, cur) =&gt; { return [...acc, ...cur.books]; }, [&quot;Hello World !&quot;]);console.log(allbooks); 배열의 중복 항목 제거 12345678let arr = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];let result = arr.sort().reduce((acc, cur) =&gt; { if (acc.length === 0 || acc[acc.length - 1] !== cur) { acc.push(cur); } return acc;}, []); 예제를 통해 알 수 있듯이 reduce 메소드는 단순히 숫자값을 누적하는 것 뿐만 아니라 배열이나 객체 자체를 다룰 때에도 유용해보입니다.","link":"/2023/01/04/230104-algo-reduce/"},{"title":"(프로그래머스 lv0) 가까운 수","text":"이 문제를 게시하는 이유 다른 사람의 풀이를 보고 느낀점이 많기 때문에. 배열과 객체를 조금 더 잘 다룰 수 있도록 연습해보는 시간이 되었던 듯 하다. 문제 설명 정수 배열 array와 정수 n이 매개변수로 주어질 때, array에 들어있는 정수 중 n과 가장 가까운 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ array의 길이 ≤ 100 1 ≤ array의 원소 ≤ 100 1 ≤ n ≤ 100 가장 가까운 수가 여러 개일 경우 더 작은 수를 return 합니다. 입출력 예 array n result [3, 10, 28] 20 28 [10, 11, 12] 13 12 입출력 예 설명 입출력 예 #1 : 3, 10, 28 중 20과 가장 가까운 수는 28입니다. 입출력 예 #2 : 10, 11, 12 중 13과 가장 가까운 수는 12입니다. 나의 풀이 발상 : n을 array안에 집어넣고 양 옆만 검사할 수 있다면 모든 요소를 순회할 필요가 없지 않을까 ? 123456789101112131415161718function solution(array, n) { const newArr = [...array, n].sort((a, b) =&gt; a - b); // n을 포함하여 sorting const nIndex = newArr.indexOf(n); // n의 index 추출 const left = newArr[nIndex - 1]; // n 기준 왼쪽 요소 const right = newArr[nIndex + 1]; // n 기준 오른쪽 요소 const leftDiff = left ? n - left : Number.MAX_SAFE_INTEGER; // n와 left의 차이 const rightDiff = right ? right - n : Number.MAX_SAFE_INTEGER; // n과 right의 차이 if (leftDiff === rightDiff) return left; // 둘이 같다면 더 작은 left 반환 return leftDiff &lt; rightDiff ? left : right; // left, right 중 더 차이가 적은 쪽을 반환} 회고 인상 깊었던 풀이 1234567let solution = (arr, n) =&gt; arr .map((e) =&gt; [e, Math.abs(e - n)]) .sort((a, b) =&gt; a[1] - b[1] || a[0] - b[0])[0][0];// map 메소드를 이용, 배열의 각 요소와 n과 요소의 차이값을 담은 배열을 담은 2차원 배열을 반환.// 배열 내 각 배열을 n과 요소의 차이값을 기준으로 오름차순 정렬. 만일 n과의 차이값이 동일하면, 요소 기준으로 오름차순 정렬.// 그렇게 정렬된 2차원 배열의 [0][0]으로 접근하면 해당 요소가 반환됨. 다만 배열로 만들었을 때 배열의 인덱스 자체에 의미가 담겨있기 때문에 가독성이 떨어져보일 수 있겠다라는 생각이 들었다.(근데 자꾸보다보니 괜찮은 것 같기도. 내가 초보자라서 독해를 못한걸수도있겠다.) 만일 의미를 붙여야한다면 객체로 만드는 건 어떨까. 그래서 만들어봤다. 1234567891011let solution = (arr, n) =&gt; { const newArr = arr.map((e) =&gt; { // 요소와 n과의 차이값을 담는 객체를 담는 배열을 반환 const data = {}; data[&quot;element&quot;] = e; data[&quot;diff&quot;] = Math.abs(e - n); return data; }); newArr.sort((a, b) =&gt; a.diff - b.diff || a.element - b.element); // 객체 프로퍼티 중 diff를 기준으로 오름차순 정렬하되, 만일 diff가 같다면 element 기준으로 오름차순 정렬 return newArr[0].element; // 첫번째 요소의 element 값을 반환}; 123456789function solution(array, n) { return array.reduce((a, c) =&gt; Math.abs(a - n) &lt; Math.abs(c - n) ? a : Math.abs(a - n) === Math.abs(c - n) ? Math.min(a, c) : c );} 위의 풀이는 이중 삼항 연산자를 이용하여 차이값이 같을 때도 고려할 수 있게 짠 듯하다.","link":"/2023/01/05/230105-algo-%EA%B0%80%EA%B9%8C%EC%9A%B4%EC%88%98/"},{"title":"Intersection Observer API","text":"Intersection Observer APIJavascrip 1차과제에서 무한 스크롤을 구현하기 위해 공부한 내용을 정리.Heropy님의 블로그를 참조합니다. 개요기준이 되는 root요소와 관찰 대상인 target의 가시성(교차) 정보를 이용해서 비동기적으로 로직을 구현할 수 있다. 장점 scroll 이벤트가 가지는 한계를 극복. scroll 이벤트와 같이 짧은 시간안에 매우 많은 횟수로 발생될 수 있는 경우 브라우저 렌더링 성능이나 이벤트 연속 호출과 같은 문제가 발생한다. Intersection Observer API를 이용해 scroll 이벤트로 퉁치는 것이 아닌 내가 설정해놓은 특정 조건에 의해 로직이 실행될 수 있도록 하였다. 사용법 new IntersectionObserver 생성자로 IntersectionObserver 객체를 생성할 수 있다. 생성자 호출 시 필수적으로 콜백함수를 인자로 제공해야한다. 이 콜백함수는 추후에 observer가 발동될 때 실행될 코드들이 들어갈 함수다. 두번째 인자로 observer 발동 조건을 조정할 수 있는 option을 인자로 제공할 수 있다. (제공하지 않으면 기본 세팅값으로 작동한다.) threshold : observer를 발동시키기 위해 관찰 대상(target)의 가시성이 얼마나 필요한지 백분율로 표시한 값을 가진다. threshold는 양방향으로 작동한다. 기본값으로 0을 지니고 있다. 이 의미는 target의 가장 자리 픽셀이 Root 범위를 교차하는 순간 observer가 발동된다는 뜻이다. 쉽게 말해 threshold : 0의 의미는 root요소를 기준으로 보이자마자 혹은, 사라지자마자 observer가 발동된다는 뜻이다. threshold 값이 0.3이라면 target의 가시성이 30% 즉, 30%정도 보이는 순간 observer가 실행된다는 뜻이다. threshold의 값으로 배열을 지정해줄 수 있는데, [0, 0.3, 1] 이라고 하면 target의 가시성이 0%, 30%, 100% 일 때 모두 observer를 발동시킨다는 의미다. root : 관찰 대상(target)의 가시성을 확인할 때 사용되는 뷰포트 요소. target의 조상 요소여야 한다. 기본값은 브라우저 viewport이며, root값이 null이거나 지정되지 않을 때 기본값으로 설정된다. rootMargin : root가 가진 여백. root요소의 각 측면의 bounding box를 수축시키거나 증가시킬 수 있다. 이는 target과의 교차성을 계산하기 전에 미리 적용되는 값이므로, 교차를 탐지하는 지점을 조정할 때 유용하게 사용될 것으로 보인다. (root가 viewport일 때) rootMargin 기본값은 0px 0px 0px 0px이므로 우리가 화면으로 보는 viewport의 사각박스가 교차점의 기준이 될 것이다. 1번에서 언급한 콜백함수는 또 다시 첫번째 인자로 IntersectionObserverEntry 인스턴스가 담긴 배열을 제공받는다. IntersectionObserverEntry로부터 target에 대한 다양한 정보들이 담긴 속성들을 제공받는다. boundingClientRect : target의 사각형 정보를 반환. intersectionRect : target과 root가 겹치는 영역에 대한 사각형 정보를 반환. intersectionRatio : target이 root와 얼마나 겹치는지의 수치를 0.0~1.0 사이의 숫자로 반환. (intersectionRect와 boundingClientRect 영역의 비율) isIntersecting : observer가 발동되는 그 순간 root와 target이 겹쳐있는가? 즉 교차하고 있는가? Boolean값으로 반환. rootBounds : root의 사각형 정보를 반환. target : 관찰 대상(Element)을 반환. time : 문서가 작성된 시간을 기준으로 교차 상태 변경이 발생한 시간을 나타내는 DOMHighResTimeStamp를 반환. 콜백함수의 두번째 인자로 콜백이 실행되는 해당 인스턴스를 제공받는다(observer). 콜백의 인자로 받기 때문에 observer가 발동하고 콜백 내부에서 unobserve() 메서드를 이용해서 관찰을 중지시킬 수도 있다. Methods observe() : target을 관찰하기 시작. unobserve() : target 관찰을 중지. disconnect() : IntersectionObserver 인스턴스가 관찰하는 모든 요소의 관찰을 중지. 기억해야할 사항들 observer는 최초 관찰을 지시받을 때(observe 메소드 호출)에도 발동되며, 이 후 관찰 조건에 충족이 될 때 마다 반복 발동된다. 여기서 말하는 isIntersecting 즉 교차란, root와 target이 겹쳐있는가 ? 를 의미한다. 교차하는 순간을 말하는 것이 아니다. (정확히 말해서 교차하는 순간은 threshold : 0 의 경우가 될 수 있겠다.) 가시성의 의미를 잘 파악하자. root 영역 내에 target이 얼마나 들어와있는가 가 되겠다. (사용자의 화면기준이 아니라 root 영역 내에서 얼만큼 보이는가 이 차이를 이해하자.) 예시 (초간단 주의)123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css&quot; /&gt; &lt;style&gt; div { margin: 100px; height: 300px; display: flex; justify-content: center; align-items: center; font-size: 100px; } div:nth-child(2n + 1) { background: orange; } div:nth-child(2n) { background: royalblue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;script&gt; const $divs = document.querySelectorAll(&quot;div&quot;); const options = { threshold: 0.5 }; // 생성자 함수의 두번째 인자로 넘겨줄 옵션 const observer = new IntersectionObserver((entries, observer) =&gt; { const props = entries[0]; // intersectionObserverEntry에 접근 if (props.intersectionRatio &gt; 0.5) { // observer 발동 조건 console.log(&quot;쨘!&quot;); // 조건 충족 시 실행될 코드 } }, options); observer.observe($divs[3]); // target($divs[3] 요소)의 관찰을 시작. &lt;/script&gt;&lt;/body&gt;","link":"/2023/01/05/230105-js-intersection-observer-api/"},{"title":"SCSS 기초","text":"SCSS Vanilla CSS만으론 효율이 떨어지고 코드가 너무 늘어지는 단점이 보여 SCSS를 적용하고자 하여 배운 내용을 간략하게 정리해본다. 세세하게 다루진 않고 핵심을 중심으로 정보들을 나열하며, 어떤 기능들이 가능한지 정도만 기록하고자 한다. 여기서 다루는 내용은 fast campus의 스타트업 프론트엔드 4기 필수 수강 강의(박영웅 강사님)의 내용에 의존합니다. 중첩 (Nesting) CSS 문법으로 원하는 요소를 선택자로 선택할 때, 내가 원하는 요소를 정확히 끌어내기 위해(중복되는 이름이 있으면 내가 원하지 않은 엉뚱한 요소에도 적용이 될 우려가 있기 때문에) 조상 요소 선택자부터 시작해서 선택자들이 늘어지는 단점이 있었다. 또한, 새로운 요소를 선택하고자 하면 또 다시 조상요소부터 거슬러 내려와 늘어지게 써야했었다. SCSS에선 중첩 문법을 지원하여 위와 같은 단점을 파훼하고 효율적인 코드 작성을 이루어냈다. 1234567891011.container .navbar { display: flex;}.container .navbar .item { width: 100px; height: 100px;}.container .navbar .item img { width: 50px; height: 50px;} 123456789101112131415.container { .navbar { display: flex; .item { width: 100px; height: 100px; img { width: 50px; height: 50px; } } }} &amp; 상위 선택자 참조 상위 선택자를 &amp; 으로 그대로 가져와 네이밍에 이어서 쓸 수 있다. (&amp;기호가 상위 선택자와 치환된다고 보면 편하다.) 123456.container { display: flex;}.container__item { flex-grow: 1;} 123456.container { display: flex; &amp;__item { flex-grow: 1; }} 이 기능은 요즘 내가 연습하고 있는 BEM 네이밍 컨벤션을 적용했을 때 더욱 효과적일 것으로 보인다. 중첩된 속성 (네임스페이스 개념) 네임스페이스란 이름을 통해 구분 가능한 범위를 만들어내는 것으로, 일종의 유효범위를 지정하는 방법을 말한다. 아예 단축 속성을 사용하거나, 단축 속성이 없는 속성들의 경우 SCSS에서 제공하는 중첩된 속성을 사용해도 효과적일 것으로 보인다. 12345.item { font-weight: 500; font-size: 12px; font-family: sans-ser;} 1234567.item { font: { weight: 500; size: 12px; family: sans-serif; }} 속성의 category를 묶어버리니 자연스럽게 css속성들끼리 섞이지도 않고 한눈에 파악하기도 좋아보여 가능하면 많이 사용하는게 좋을 것 같다. Variables 자주 사용되는 수치나, 페이지 내에서 중용되는 main theme 속성들의 경우 변수를 선언해서 재사용하면 편리하다. CSS에서도 사용할 수 있으며 SCSS에서 사용되는 문법을 정리한다. 잊어버리기 쉬운, 그러나 중요한 개념 : 식별자는 scope(유효 범위)를 가지며, 식별자가 선언된 위치에 의해 결정된다. CSS에서 모든 변수들을 전역에서 선언하고 사용하는 경우가 많은데, 가능하다면 해당 변수가 어디에서 어디까지 필요하고, 그에 따라 스코프를 줄여보는 건 어떨까 ? 변수의 선언에 사용되는 기호 : $, 세미 콜론;으로 마무리 짓기. 산술 연산 기본적인 산술이 가능함. 다만, 나누기 /의 경우 단축 속성 구분자로서 동작이 가능하기 때문에 단독으로 그냥 쓰면 동작하지 않는다. 소괄호로 묶거나 변수와 함께 쓰거나 다른 연산자와 함께 쓰면 아 이 /기호는 나눗셈을 위한 것이구나, 라고 엔진이 인식할 수 있기 때문에 위와 같이 사용하자. 근데 그냥 calc()를 쓸 것 같다. Mixins (재활용) CSS에서 자주 사용되는 조합의 경우 함께 묶어놓고 필요할 때 가져다 사용하면 매우 편리하지 않을까 ? 예를 들어, flex item들을 가운데 정렬하기 위해 flex container에 선언하는 다음과 같은 속성들 말이다. 12345.flex-container { display: flex; justify-content: center; align-items: center;} 즉, Mixins은 자주 사용되는 CSS 코드들을 묶어서 재활용하기 위해 태어났다. 마치 변수나 함수를 이용하는 것처럼 말이다. 123456789101112@mixin f-center { // f-center라는 mixin 식별자를 규정하고, 아래와 같이 재사용할 코드들을 나열한다. display: flex; justify-content: center; align-items: center;}.container { @include f-center // 원하는 mixin 식별자를 @include 키워드와 함께 불러온다. // 나머지 CSS속성들은 이어서 쓰면 된다.;} 123456// 위의 scss code를 css로 compile 했을 때.container { display: flex; justify-content: center; align-items: center;} SCSS는 한 단계 더 나아가 Mixin을 조금 더 유동적으로 사용하고자 한다. Mixins은 매개변수를 지정하여 원하는 인수를 받아 내부의 CSS 속성에 적용할 수 있다. 만일 매개변수에 주어지는 인수가 없는 경우를 위해 기본값을 지정할 수 있다. : 콜론을 사용한다. Mixin이 여러 매개변수를 사용할 때엔 매개변수의 순서에 맞게 인수를 넣어줘야 하는데, 다른 매개변수를 건드리지 않고 특정 인수만 전달하고 싶을 땐 키워드 인수를 활용하도록 하자. 매개변수 기본값을 설정할 때 처럼 : 사용. 반복문 값을 처리하는 부분은 그대로 변수를 사용, 값을 처리하지 않는 부분에서 사용 시엔 보간을 사용함. 사용되는 기호 : #{} (SCSS에서 변수를 선언할 때 $가 사용되기 때문에 #을 차용한 것이라 이해하자.) 12345@for $i from 1 through 3 { .container:nth-child(#{$i}) { width: 100px * $i; }} 1234567891011.container:nth-child(1) { width: 100px;}.container:nth-child(2) { width: 200px;}.container:nth-child(3) { width: 300px;} 함수 Mixin과의 차이점이라고 한다면, 함수 내에서 연산한 결과값을 return 받아 사용할 수 있다는 점..? 화면 비율에 따라 width를 조정해서 쓰는 경우 등등.. 많이 쓰일 것 같진 않아보인다. 123456789@function ratio($size, $ratio) { @return $size * $ratio;}.box { $width: 100px; width: $width; height: ratio($width, 1/2);} 1234.box { width: 100px; height: 50px;} 색상 내장 함수 mix($color1, $color2) : 두 개의 색상을 섞은 색을 반환 lighten($color, 10%) : 색상을 10% 더 밝게 darken($color, 10%) : 색상을 10% 더 어둡게 2,3번은 mouse hover효과를 줄 때 자주 사용될 것으로 보인다. saturate($color, 10%) : 색상의 채도를 10% 상승 desaturate($color, 10%) : 색상의 채도를 10% 하강 grayscale($color) : 색상을 회색으로 변환 invert($color) : 색상 반전 rgba($color, 0.3) : 색상의 불투명도를 조절 모듈 참조 CSS와의 차이점 url함수 사용 X 확장자 필요없음 1@import url(&quot;./variables.css&quot;); 1@import &quot;./variables&quot;; 여기서부턴 상대적으로 중요도가 떨어지므로 참고용 데이터 종류 숫자, 문자, 색상, boolean, list, map 반복문(@each) list 데이터 활용 1234567$color: orange, tomato, royalblue;@each $c in $color { .box { color: $c; }} 1234567891011.box { color: orange;}.box { color: tomato;}.box { color: royalblue;} map 데이터 활용 1234567891011$colormap: ( o: orange, t: tomato, rb: royalblue,);@each $k, $v in $colormap { .box-#{$k} { color: $v; }} 1234567891011.box-o { color: orange;}.box-t { color: tomato;}.box-rb { color: royalblue;} 재활용(@content) 기존의 Mixin에 CSS속성을 추가적으로 넣고 싶을 때 사용 123456789101112@mixin center { display: flex; justify-content: center; align-items: center; @content;}.box { @include center { margin-top: 100px; }} 123456.box { display: flex; justify-content: center; align-items: center; margin-top: 100px; // @include 구문 옆의 중괄호 안의 내용이 content에 담기고, mixin내부에서 content를 불러오는 느낌.} 그런데 이렇게 하지 않고 @include 이후에 css를 계속 작성할 수 있는데 content를 쓰는 경우가 있을까 싶다.","link":"/2023/01/07/230107-css-scss/"},{"title":"Javascript 정규표현식 적응하기 (++꾸준히 업데이트)","text":"정규 표현식 지난 알고리즘 스터디 영찬님 발표 때 정규표현식을 처음 접했고, 이후 문제풀이에서 문자열 탐색 문제에 적용해보고자 간단하게 공부한 내용을 정리해봅니다.Heropy님 블로그에 너무 정리가 잘되어있다. 개요 정규표현식은 기본적으로 문자열을 탐색하기 위한 방법의 하나로, 문자열 메서드와 조합하여 많이 사용한다고 한다. 패턴과 플래그를 이용하여 생성한 정규표현식을 이용하여 대상 문자열을 탐색하여 결과를 얻어낸다! 로 요약이 가능하겠다. 패턴을 문제 상황의 요구 조건에 맞게 얼마나 잘 표현을 하느냐가 중요해보인다. 패턴을 작성하는데 사용되는 여러 클래스들이 존재한다. 정규표현식 생성에는 리터럴 방식(/pattern/flag)과 RegExp 생성자 함수를 이용한 객체 생성 두 가지가 있다. 전자는 코드를 작성하고 있는 시점에 정확한 패턴을 알고있을 때 사용. 보통 사용하게 될 방식. 후자는 상황에 따라 정규표현식을 동적으로 생성해야할 때 사용. 생성자 함수의 인자로 패턴과 플래그를 넘겨준다 (상황에 따라!). 정규표현식은 많이 알아두면 알아둘 수록 문자열 탐색에 있어서 아주 편리할 것 같다. 근데 그 표현식이 너무 많아보이는구나하ㅏ함…. 정규표현식 메소드 메소드 문법 설명 exec 정규식.exec(문자열) 일치하는 하나의 정보(Array) 반환 test 정규식.test(문자열) 일치 여부(Boolean) 반환 search 문자열.search(정규식) 일치하는 문자열의 인덱스(Number) 반환 replace 문자열.replace(정규식, 바꿀 문자) 일치하는 문자열을 지정 문자열로 교체하고 교체된 문자열 반환 match 문자열.match(정규식) 일치하는 문자열의 배열 반환 split 문자열.split(정규식) 일치하는 문자열을 분할하여 배열(Array)로 반환 단순히 true or false 값을 원한다면 test, search 메소드를 이용하자. 플래그 플래그 설명 g(global) 모든 문자와 여러 줄 일치(global) i(ignore) 영어 대소문자를 구분 않고 일치 m(multiLine) 여러 줄 일치 패턴 정규식 패턴 설명 [a-z] a부터 z 사이의 문자 구간에 일치(영어 소문자) [A-Z] A부터 Z 사이의 문자 구간에 일치(영어 대문자) ^ 줄의 시작에서 일치 /^abc/ $ 줄의 끝에서 일치 /xyz$/ . 임의의 한 문자와 일치 a&amp;verbar;b a 또는 b와 일치 /h..p/ ab? b가 없거나 b와 일치 https? {3} 3개 연속 일치 {3,} 3개 이상 연속 일치 {3,5} 3~5개 연속 일치 [abc] a 또는 b 또는 c와 일치 [a-z] a부터 z 사이의 문자 구간에 일치(영어 소문자) [A-Z] A부터 Z 사이의 문자 구간에 일치(영어 대문자) [0-9] 0부터 9 사이의 문자 구간에 일치(숫자) [가-힣] 가부터 힣 사이의 문자 구간에 일치(한글) [^abc] a 또는 b 또는 c가 아닌 나머지 문자에 일치(부정) \\ 이스케이프 문자, /\\.\\?\\/\\$\\^/ \\w(word) 63개 문자(영문 대소문자 52개 + 숫자 10개 + _(underscore))에 일치 \\b(boundary) 63개 문자(영문 대소문자 52개 + 숫자 10개 + _(underscore))가 아닌 나머지 문자에 일치하는 경계(boundary) \\d(digit) 숫자에 일치 \\s(space) 공백(Space, Tab, 줄바꿈 등)에 일치 (?=) 앞쪽 일치(Lookahead) (?&lt;=) 뒤쪽 일치(Lookbehind) * 0회 이상 연속으로 반복되는 문자와 가능한 많이 일치, {0,}와 동일 *? 0회 이상 연속으로 반복되는 문자와 가능한 적게 일치(lazy), {0}와 동일 + 1회 이상 연속으로 반복되는 문자에 가능한 많이 일치, {1,}와 동일 +? 1회 이상 연속으로 반복되는 문자에 가능한 적게 일치(lazy), {1}와 동일 () 그룹화 주의) 줄 끝이라 함은 기본적으로 문자열의 가장 끝을 의미. (end quote의 바로 앞) 이 때, 줄 바꿈을 반영하려면 mflag를 사용 정규 표현식 예시 /\\bf\\w{1,}\\b/g : f로 시작하는 모든 영단어 검색 /.{1,}(?=@)/g : @ 앞쪽의 연속되는 모든 문자 (주로 이메일 처리할 때) /(?&lt;=@).{1,}/g : @ 뒤쪽의 연속되는 모든 문자 (주로 이메일 처리할 때) 문자열.replace(/\\s/g, &quot;&quot;) : 공백 처리할 때 str.match(/\\((.*)\\)/)[1] : 괄호 사이 값 추출","link":"/2023/01/07/230107-js-regexp/"},{"title":"Parcel 개요","text":"번들러 개요 HTML, CSS, JS 만으로 코드를 짜는 것은 굉장히 비효율적이다. 현실에서 그렇게 썼다간 .. ;;; 코드 작성의 효율을 극대화할 수 있는 여러가지 고도화된 기능을 이용하여 코드를 짠다. (CSS의 전처리기인 SCSS, JS 호환성과 최신 기능을 지원해주는 Babel, 브라우저와 모듈 시스템?) 그러나 위와 같은 방식으로 만들어진 코드가 브라우저 위에서 동작하는 것은 아니다. 즉, 브라우저가 정상적으로 인식할 수 있도록 컴파일링(트랜스파일링)을 통해 변환된 뒤에 비로소 브라우저 위에서 동작하는 것이다. 여기서 프로젝트에 사용된 다양한 기술들 각각에 맞게 컴파일링에 필요한 외부 모듈(패키지)들을 인식하고 자동으로 설치해주어 개발 작업을 자동화해주는 것이 바로 번들러이다.","link":"/2023/01/08/230108-bundler-parcel/"},{"title":"Javasript 표준 내장 객체 Method (지속 업데이트 필요)","text":"Javascript 표준 내장 객체 본 포스팅은 패스트캠퍼스 박영웅 강사님의 강의를 기반으로 합니다. 본 포스팅의 메서드 구분 방법 프로토타입 메서드 : .으로 시작합니다. 정적 메서드 : 클래스부터 시작합니다. Array .forEach() forEach메서드는 해당 메서드의 폴리필에서 볼 수 있듯이, 내가 원한다고해서 중간에 순회를 중단할 수 없다. for 반복문에서는 break 키워드를 통해 가능하다는 점이 차이. 배열의 요소 수가 굉장히 많은게 아니라면 가독성이 상대적으로 더 좋은 forEach를 사용하자. forEach내부의 콜백으로 async function을 제공하면 의도대로 작동하지 않는다. foreach 는 배열 요소를 순차적으로 돌면서 callback을 실행할 뿐, callback이 끝날때 까지 기다렸다가 다음 callback을 실행하는 것이 아니라고 한다. 즉, foreach 자신이 실행하는 코드가 비동기를 하든 안하든 관심이 없이 넘어간다는 것이다. (병렬 처리 느낌 script 로드할 때 async 속성 부여한 느낌) 위의 경우 대신 for 반복문 사용하기 .map() 각 요소를 순회하며 각각을 콜백 함수가 반환하는 값으로 대체하여 새로운 배열을 반환. 원본 배열과 length가 동일. 배열에 요소를 추가나 삭제할 필요 없이, 데이터를 공통적으로 가공할 때 유용해보인다. 123456789101112131415const users = [ { name: &quot;Neo&quot;, age: 85 }, { name: &quot;Amy&quot;, age: 22 }, { name: &quot;Lewis&quot;, age: 11 },];const newUsers = users.map((user) =&gt; ({ // 3. 객체로 반환한다. 객체 리터럴을 반환하므로 소괄호로 묶어줌 (중괄호 구분) ...user, // 1. 요소의 기존 내용물을 열거하고, isValid: true, // 2. 새로운 내용을 더해서 email: null, // 2. 새로운 내용을 더해서}));const userNames = users.map((user) =&gt; user.name);console.log(newUsers); // [{ name: 'Neo', age: 85, isValid: true, email: null }, ...]console.log(userNames); // ['Neo', 'Amy', 'Lewis'] .includes() 배열 내에 지정된 요소가 있는지 여부를 Boolean 값으로 반환 주의) 참조형 데이터(객체)를 인자로 넘겨줄 땐 리터럴로 넘겨주면 안된다. 탐색 대상에 존재하는 참조형 데이터 자체를 변수에 담아서 사용하기. 선행 개념 : 데이터의 가변성과 불변성 .every() 대상 배열의 모든 요소가 콜백 테스트를 통과 (Truthy) 하는지 여부를 Boolean 값으로 반환 최초로 테스트가 실패하면 이후 테스트를 더 이상 진행하지 않고 false를 반환. .some() 대상 배열 중 일부가 콜백 테스트를 통과하는지 여부를 Boolean 값으로 반환. 마찬가지로 첫 통과가 나오면 이후 콜백을 실행하지 않는다. .filter() 대상 배열에서 콜백 테스트를 통과하는 요소들만으로 이루어진 새로운 배열을 반환. 모든 요소가 콜백 테스트를 통과하지 못하면 빈 배열을 반환 .find() 대상 배열에서 콜백 테스트를 통과하는 첫 번째 요소를 반환 최초로 테스트가 통과되면 이후 콜백은 실행하지 않는다. 모든 테스트 실패 시 undefined 반환 객체를 다룰 때 find 메서드의 반환값을 truthy, falsy로 활용할 수 있겠다. .findIndex() .find()메서드와 동일, 찾은 요소의 인덱스를 반환 없으면 -1 반환. .at() 대상 배열을 인덱싱 음수값을 사용하면 뒤에서부터 인덱싱. –&gt; 이 때 유용해보인다. .concat() 배열을 병합. 스프레드 연산자로 대체가 가능하다. .reverse() 대상 배열의 순서를 반전. 원본 배열을 직접 바꾼다. (부수 효과 O) .join() 대상 배열의 모든 요소를 구분자로 연결한 문자를 반환 .sort() 원본 배열을 직접 바꾼다. (부수 효과 O) 대상 배열을 콜백의 반환 값에 따라 정렬 음수 : a를 낮은 순서로 정렬 0 : 순서 변경 없음 양수 : b를 낮은 순서로 정렬 콜백의 반환값 부호에 집중하는 것이니 내부의 로직을 조금 더 복잡하게 가져가면 단순 숫자 정렬이 아닌, 객체 데이터를 다루는 데에도 용이해보인다. 1234567891011const users = [ { name: &quot;Neo&quot;, age: 85 }, { name: &quot;Amy&quot;, age: 22 }, { name: &quot;Lewis&quot;, age: 11 },];users.sort((a, b) =&gt; a.age - b.age);console.log(users); // [ Lewis객체, Amy객체, Neo객체 ]// users.sort((a, b) =&gt; b.age - a.age)// console.log(users) // [ Neo객체, Amy객체, Lewis객체 ] 콜백을 제공하지 않으면, 요소를 문자열로 변환하고 유니코드 코드 포인트 순서로 정렬. .flat() 대상 배열의 모든 하위 배열을 지정한 깊이(depth)까지 이어붙인 새로운 배열을 반환. 깊이의 기본값 : 1 Object Object.assign() 하나 이상의 출처 객체로부터 대상 객체로 속성을 복사하고 대상 객체를 반환. 첫 번째 인수가 대상 객체가 되고, 두 번째 인수 이후부터 모두 출처 객체가 된다. 객체 내 각 프로퍼티는 고유하다. 고로 프로퍼티가 중복되면 나중에 복사되어 들어오는 프로퍼티가 이전 것을 덮어쓴다. 대상 객체(원본)가 수정된다. 고로 원본을 유지해야한다면, 대상객체에 빈 객체({})를 제공하자. Object.entries() 주어진 객체의 각 속성과 값으로 하나의 배열을 만들어 요소로 추가한 2차원 배열을 반환12345678910111213const user = { name: &quot;Heropy&quot;, age: 85, isValid: true, email: &quot;thesecon@gmail.com&quot;,};for (let [key, value] of Object.entries(user)) { console.log(key, value);}// name Heropy// age 85// isValid true// email thesecon@gmail.com Object.freeze(), Object.isfrozen() 주어진 객체를 변경할 수 없도록 동결하거나, 동결 여부를 확인 Object.seal(), Object.isSealed() 동결과 다른 점은 밀봉 후에도 이미 존재하는 속성의 값은 변경 가능. 동결과 마찬가지로 여전히 추가/삭제 불가 Object.defineProperty(객체, 프로퍼티, 옵션 객체) 주어진 객체에 속성을 추가하거나, 특성을 변경 옵션들 enumerable : false configurable : false writable : false value : undefined get : undefined set : undefined 일반적인 객체는 13번 모두 true. 본 메서드로 프로퍼티 생성 시 해당 프로퍼티는 13번 모두 false 중요 : getter, setter getter는 프로퍼티에 접근(get)할 때 실행되는 get() 함수. setter는 프로퍼티의 값으로 무언갈 할당(set)할 때 실행되는 set() 함수. 값을 얻으려고 할 때, 혹은 값을 할당하려 할 때, 추가적인 로직을 부여할 수 있음 즉, 데이터를 감시할 수 있게 된다는 점이 아주 중요하다. getter와 setter는 함수지만, 흔히 알고있는 함수의 호출 형태로 실행되는 것이 아님! 참고) 객체의 속성 제거엔 delete 키워드 참고) 식별자 앞의 underscore(_)는 해당 식별자는 숨기겠다는 개발자의 의도가 담겨있음. (실제로 숨김처리가 되는 건 아님.) const user = { firstName: &quot;bongbong&quot;, lastName: &quot;Ko&quot;, }; Object.defineProperty(user, &quot;fullName&quot;, { get() { return `Full Name is ${this.lastName} ${this.firstName}`; }, set(str) { const nameArr = str.split(&quot; &quot;); this.lastName = nameArr[0]; this.firstName = nameArr[1]; }, }); JSON 통신용 데이터 포맷 (즉, 기본적으로 서버와의 통신은 JSON이다.) 문자, 숫자, Boolean, null, 객체, 배열만 지원. 후행 쉼표 허용 X 큰 따옴표만 허용 JSON.stringify() JSON.parse()","link":"/2023/01/10/230110-js-builtin-methods/"},{"title":"분류되지 않은 내용들 임시 저장소 입니다.","text":"전위/후위 증감 연산자 전위 증감 연산자 : 연산 후 할당 123let x = (y = 3);y = ++x;console.log(x, y); // 4, 4 후위 증감 연산자 : 할당 후 연산 123let x = (y = 3);y = x++;console.log(x, y); // 4, 3 디바운스와 스로틀 프로그래밍 기법 scroll, input, resize, mousemove와 같이 짧은 시간 안에 다량의 이벤트를 발생시키는 것들을 이벤트로서 다룰 때 주의를 요함. 디바운스 : 쉽게 말해, 정해진 시간(delay)이 되기 전에 이벤트를 호출하면 직전에 발생한 이벤트를 취소시키고 새로 시간을 재는 것. “취시(취소 시작)” 느낌 스로틀 : delay 시간 안에 발생한 동일한 이벤트를 하나로 퉁침. 자세한건 deep dive 책의 디바운스, 스로틀 폴리필을 참고하자. 실무에서는 디바운스, 스로틀 관련 라이브러리 (ex. Lodash)를 가져다 쓰는 것을 권장. 디바운스 폴리필 : 클로저 활용. 엄밀하게 말하면 모든 함수는 클로저. 그러나 그렇게 부르지 않음. 클로저 : 특수한 함수 –&gt; 외부 함수보다 오래살아남은 중첩함수. 상위 스코프를 기억. 즉, 생명주기가 종료된 외부함수(상위 스코프)의 변수에 접근 가능. 가비지 콜렉터는 누군가가 참조하고 있는 값을 함부로 지우지 않음. 클로저로 이어지는 선개념 : 렉시컬 스코프. (정적 스코프) 즉, 자신이 정의된 위치에 따라 스코프가 결정. “클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다” 함수의 인자로 들어온 값을 객체 프로퍼티로 쓸 수 없다. (?)1234567const arr = [1, 2, 3, 4];arr.map((num) =&gt; ({ num: num }));// (4) [{…}, {…}, {…}, {…}]// 0: {num: 1}// 1: {num: 2}// 2: {num: 3}// 3: {num: 4} 의도한 건 [{ 1 : 1 }, { 2 : 2 }, { 3 : 3 }, { 4 : 4 }] 이건데 안되나보다.. 아래와 같이 쓰자. 123456const arr = [1, 2, 3, 4];arr.map((num) =&gt; { const obj = {}; obj[num] = num; return obj;});","link":"/2023/01/10/etc/"},{"title":"23년 1월 2주차 주간회고","text":"주간 회고 (22.01.05 ~ 23.01.10) 한 주간 배운점, 느낀점, 보완해야할 점을 keyword 중심으로 나열합니다. 배운점 JavaScript Intersection Observer API Intersection Observer의 생성(callback, option) target, root요소 기타 주의 사항 관련 포스팅 보러가기 정규표현식 배워야하는 이유 생성, 패턴, 플래그, 조합 메서드 관련 포스팅 보러가기 parcel 번들러 도입 왜 번들러가 탄생할 수 밖에 없었는가 ? 번들러 개요 (code split, minify, compile, HMR …) 다중 entry point (Multi Page) 관련 포스팅 보러가기 CSS CSS Preprocessor인 SCSS를 도입 Nesting, Mixin, loop, function, color builtin function … compiler (vscode의 Live Sass Compiler 혹은 다른 태스크 러너, 번들러) 관련 포스팅 보러가기 느낀점 이번 주는 JS 1차과제를 하는데 대부분 시간을 보냈다.이번 주를 요약하자면 다음 두 가지로 정리할 수 있겠다. 알고리즘의 비중을 낮추고 (스스로) 구현을 해보는데에 더욱 집중할 것. 그 과정은 필히 선 로직 후 코딩이 되어야 한다. SCSS에 더욱 친숙해질 것, layout을 짜는 연습을 할 것. 이번 JS 과제는 영화 검색 API를 만드는 것이었다. 당연히 Vanilla JS의 연습에 목적을 둔 과제였다. 페이지의 디자인은 자율형식이었다. html과 css가 너무 부족하다보니 첫 시작이 너무 오래걸렸다. 아직은 layout을 다루는 것과 css 네이밍, css 속성들에 대해 익숙치 않다보니 js과제임에도 html/css를 짜는데 더욱 시간을 많이 쏟은 것 같다. 한가지 다행스러운 점은 html/css는 하면 할 수록 숙련도가 높아질 수 밖에 없겠다라는 느낌을 받은 것이었고, 앞으로 남은 기간동안에도 꾸준히 클론 코딩을 통해 감을 잃지 않도록 꾸준히 연습하리라 다짐했다. 그렇다고 js부분은 쉬웠나 ? 그것도 아니었다. intersection observer api 사용법을 익히는데에 절반을 보낸 것 같고, 내가 짠 함수들도 로직이 뒤죽박죽 느낌이 많이 들었다. 그 과정 중에 들었던 생각 두 가지가 있다. 첫 번째는 위에서 설명했듯 로직을 먼저 짜고 들어가자, 두 번째는 만들고 끝내지말고 반드시 refactoring을 해보자는 것이다. 처음 코딩할 떄와, 두 번째 볼 때, 세 번째 볼 때 느낌이 매번 다르고, 고쳐야할 부분이 보이면서 다음 프로젝트 때 이 경험을 바탕으로 조금 더 나은 코드를 짤 수 있으리라 생각이 들었다. 보완해야할 점 로직은 내가 관리하게 될 변수와, 변수의 스코프를 항상 염두에 두고 짜자. 함수는 그 기능을 보다 명확하고 간결하게 짜도록 노력하자. 프로젝트를 단순히 기능만 구현한 상태로 끝내지말고 리팩토링과 기능 추가를 더해보자 생각한대로 기능이 작동하지 않는다면, debugging을 통해 변수의 상태와 스코프, 스택을 눈으로 직접 확인하는 과정을 거치자.","link":"/2023/01/11/wil-2301-2nd/"},{"title":"TIL 230112 javascript","text":"Module, AsynchronousModule(ES6 Module) 모듈 시스템이 필요한 이유 강사님의 비유 : PC 분해/조립 (유지/보수의 관점) 그럼 어떤 기준으로 Module을 나누나 ? : 기능 단위 index.html에 main source가 되는 하나의 js파일을 진입점(entry point)으로 하위의 여러 js파일 간 의존성 구조가 형성된다. 내보내기 (export) 내보내기의 두 가지 종류 기본 내보내기 (default) 모듈 당 1번 내보낼 때 이름을 붙여도 되고, 안 붙여도 됨. 이름 내보내기 모듈 당 n번 이름을 붙여야 함. 즉, data 자체를 내보낼 수 없음. 식별자에 담고 식별자를 내보내야 한다. 내보내질 아이들은 기본적으로 하나의 객체에 모두 담겨 나간다. 내보내지는 아이가 하나여도.(그래서 추후에 import할 때도 중괄호로 받아야함. 마치 객체 구조 분해 할당하는 것 처럼) 내보낼 때 as 키워드이름을 바꿀 수 있음. 가져오기 (import) 기본 내보내기의 데이터 받기 변수에 담긴 담는데 아무렇게 작명해서 받아도 ok. 이름 내보내기의 데이터 받기 내보내질 때의 식별자 대로 받아야함. 그대로 받기는 받고, 받은 모듈 내에서 사용할 이름은 as키워드로 바꿀 수 있음. import * as !식별자 from './module.js' !식별자는 데이터들을 한데 모은 객체로 이어 받음. 이름 내보내기에 의한 데이터들은 해당 이름이 프로퍼티가 됨. default 내보내기에 의한 데이터는 !식별자 객체의 default 프로퍼티의 값으로 들어온다. 동적 모듈 가져오기 기본적으로 import문은 모듈의 최상단에 위치해야한다. 코드의 임의의 위치에서 가져오고 싶을 땐 ? import 함수 import 함수는 시간이 얼마나 걸릴지 모르는 작업이며, import 함수의 반환값은 Promise instance이다. 그 말은 await 키워드를 활용할 수 있다는 말. 가져오자마자 내보내기 추후 Update 예정","link":"/2023/01/12/til-230112-js/"},{"title":"비동기 pattern (Callback, Promise Async&#x2F;Await)","text":"Callback Pattern 비동기 처리 결과의 후속처리를 위한 노력 - Callback Function 비동기 처리 결과를 외부로 반환하거나, 상위 스코프의 변수에 할당해도 기대한대로 동작하지 않는다. 비동기 함수는 비동기 처리를 기다리지 않고 즉시 종료되기 때문. 비동기 처리 결과를 위한 후속처리는 비동기 함수 내부에서 수행해야한다. 따라서 비동기 처리 결과에 대한 후속 처리를 수행하는 callback 함수를 인자로 전달한다. 이와 같은 Callback pattern은 통상 Callback Hell - 중첩, 복잡도 상승라고 부르는 가독성 문제를 일으킨다. Error 처리의 한계 Callbakc Pattern의 가장 큰 단점은 에러 처리가 곤란하다는 점이다.1234567try { setTimeout(() =&gt; { throw new Error(&quot;Error가 발생했습니다&quot;); }, 1000);} catch (err) { console.error(&quot;catch :&quot;, err);} 위의 예제에서 try문 안의 setTimeout 함수는 설정된 1초가 지나면 콜백함수를 호출하고, 콜백함수는 에러를 발생시킨다. 하지만 콜백함수가 발생시킨 error는 catch문에서 잡아내지 못한다. setTimeout함수의 콜백함수가 실행될 때 setTimeout함수는 이미 콜 스택에서 제거된 이후이다. (콜 스택과 이벤트 루프 참고) 그 말인 즉슨, setTimeout 함수의 콜백함수를 호출한 것(호출자-caller)이 setTimeout 함수가 아니라는 것을 의미한다. 에러는 호출자(caller) 방향으로 전파된다. (즉, 콜 스택의 아래 방향으로 전파됨) 따라서 setTimeout 함수의 콜백함수가 던진 에러는 catch문에서 잡을 수가 없는 것이다. 위와 같은 콜백 헬, 에러 처리의 한계를 극복하기 위해 Promise Pattern이 등장하게 된다. Promise 프로미스의 생성 new Promise 생성자 함수 구문으로 Promise 인스턴스를 생성한다. Promise 생성자 함수의 인자로 비동기 처리를 수행할 콜백 함수를 제공한다. 콜백 함수는 다시 resolve 함수와 reject 함수를 인자로 받는다.12345678const promise = new Promise((resolve, reject) =&gt; { // asynchronous code if(/* successful */) { resolve('result') } else if (/* failure */) { reject('error') }}) resolve, reject Promise는 세 가지 state를 가진다. state 의미 상태 변경 조건 pending 비동기 처리가 아직 수행되지 않은 상태 프로미스가 생성된 직후 기본 상태 fulfilled 비동기 처리가 수행된 상태(성공) resolve 함수 호출 rejected 비동기 처리가 수행된 상태(실패) reject 함수 호출 후속 처리를 위한 작업을 위해 resolve 함수의 인자로 비동기 처리 결과를 넘겨주고, reject 함수의 인자로 에러 객체를 넘겨주어 체이닝을 통해 후속처리를 진행한다. resolve, reject 함수가 필요한 이유를 요약하면 다음과 같다. pending 상태의 프로미스를 settled(fulfilled or rejected) 상태로 변경하는 역할 수행 비동기 처리 결과를 후속 처리 메서드에 전달하는 역할 (프로미스 체이닝) Promise 후속처리 메서드 then 첫 번째 인자 : 프로미스가 fulfilled 상태가 되었을 때 실행시킬 콜백 함수. 콜백 함수는 다시 첫 번째 인자로 프로미스가 resolve한 값을 받는다. 두 번째 인자 : 프로미스가 rejected 상태가 되었을 때 실행시킬 콜백 함수. 콜백 함수는 다시 첫 번째 인자로 프로미스가 reject한 값을 받는다. catch then의 두번째 인자로 넘겨준 callback함수가 에러 처리를 수행할 수 있지만, catch 메서드의 콜백함수로 error를 처리하도록 하자. finally Promise의 처리 결과와 상관없이 한 번 수행될 로직을 짠다. Promise 후속처리 메서드는 Promise 체이닝을 통한 후속처리를 위해 항상 프로미스를 반환한다. 만약 후속처리 메서드의 콜백함수가 명시적으로 프로미스가 아닌 값으로 반환을 해도 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성해 반환한다. Promise 정적 메서드 Promise.resolve / Promise.reject 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다. Promise.all 여러 비동기 처리를 묶어 병렬 처리할 때 사용. 모든 비동기 처리가 fulfilled 될 때 까지 기다리며, 전부 fulfilled 상태가 되면 각각의 resolve값들을 배열에 저장하고 해당 배열을 resolve하여 새로운 Promise를 반환한다. 비동기 처리 중 하나라도 reject가 되면 나머지 비동기 처리를 기다리지 않고 즉시 종료한다. Promise.race Promise.all 처럼 모든 비동기 처리가 fulfilled 되기를 기다리는 것이 아니라, 가장 먼저 fulfilled 된 프로미스가 resolve한 값을 resolve하여 새로운 Promise를 반환한다. 마이크로태스크큐 프로미스의 비동기 함수는 태스크 큐가 아닌 별도의 큐가 관리를 하는데, 이를 마이크로태스크 큐라고 한다. 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다. 1234567setTimeout(() =&gt; console.log(1), 0);Promise.resolve() .then(() =&gt; console.log(2)) .then(() =&gt; console.log(3));// 2, 3, 1 Async/Await async/await 는 Promise를 기반으로 동작한다. Promise 후속처리 메서드 역시 콜백을 전달하는 callback pattern을 사용했지만, async/await 문법을 통해 후속 처리 메서드 없이 마치 동기적으로 돌아가는 것처럼 구현할 수 있게 되었다. async 함수 await 키워드는 반드시 async 함수 내에서 사용해야한다. async 함수는 언제나 프로미스를 반환한다. async 함수 내에서 await 키워드를 만나면 이후의 코드는 마이크로태스크큐로 넘어간다. await 키워드 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 값을 반환한다. (프로미스를 반환하는 것은 아님.)123const promise = Promise.resolve(1);const res = await promise;console.log(res); // 1 await는 반드시 Promise 앞에서 사용해야한다. 에러 처리 try ~ catch 문을 사용. async 함수 내에서 catch문으로 에러 처리를 하지 않으면 async함수는 발생한 에러를 reject하는 프로미스를 반환한다. 이를 이용하여 async 함수의 후속 처리로 catch 메서드를 이어 붙일 수 있다. 최신 문법 Update 전역 환경에서는 async 함수로 래핑하지 않고 await 키워드 단독으로 사용할 수 있게 되었다.","link":"/2023/01/13/230113-js-promise/"},{"title":"에러 처리","text":"에러 처리 영화 검색 api 토이 프로젝트를 진행하면서 에러 처리의 필요성을 느끼고 관련된 내용을 정리해보고자 한다. 에러 처리의 필요성 에러가 발생하지 않는 코드를 작성하는 것은 정말 안타깝지만 불가능하다. 에러가 발생하면 프로그램은 강제 종료된다. 그러니 에러 처리는 진짜 중요하다.. 기본적으로 에러를 처리하는 방법은 두 가지있다. 예외적인 상황이 발생하면 반환하는 값(예를 들어, Array.prototype.indexOf() 메서드가 반환하는 -1 이나, querySelector 메서드가 찾는 요소가 없을 때 반환하는 null)을 if 조건문이나, 단축 평가 또는 옵셔널 체이닝 연산자를 통해 확인해서 처리하는 방법 에러 처리 코드를 미리 등록하고 에러가 발생하면 에러 처리 코드로 점프하도록 하는 방법 여기서 다루는 에러 처리에 관한 이야기는 2번의 경우가 되겠다. try ~ catch ~ finally 문12345678try { // 에러 발생의 여지가 있는 코드} catch (err) { // try문 내에서 에러가 발생하면 실행될 코드 // err에는 try문에서 발생한 에러 객체가 담긴다.} finally { // 에러 발생과 상관없이 반드시 한 번 실행될 코드} Error 객체 Error 생성자 함수는 에러 객체를 생성한다. Error 생성자 함수가 생성한 에러 객체는 message 프로퍼티와 stack 프로퍼티를 갖는다. message 프로퍼티의 값은 Error 생성자 함수에 인수로 전달한 에러 메세지이다. stack 프로퍼티의 값은 에러를 발생시킨 콜 스택의 호출 정보를 나타내는 문자열이다. (디버깅 목적) 자바스크립트는 Error 생성자 함수를 포함해 7가지 Error 객체를 생성할 수 있는 생성자 함수를 제공한다. Error, SyntaxError, ReferenceError, TypeError, RangeError, URIError, EvalError throw 문 Error 생성자 함수로 에러를 생성한다고 에러가 발생되는 것은 아니다. 에러의 생성과 에러의 발생은 다르다. 에러를 발생시키려면 에러 객체를 던져야 한다. throw 표현식; 에러를 던지면 catch문의 에러 변수가 생성되고 던져진 에러 객체가 할당된다. 그리고 catch문이 동작하기 시작한다.1234567try { throw new Error(&quot;에러 발생&quot;);} catch (err) { console.log(err);}//Error: 에러 발생// at &lt;anonymous&gt;:2:11 에러의 전파 throw된 에러를 캐치하지 않으면 호출자 방향으로 전파된다. 에러는 호출자 방향으로 전파된다. 즉, 콜 스택의 아래 방향으로 전파된다. 이 과정에서 throw된 에러를 캐치하여 적절히 대응하면 프로그램을 강제 종료시키지 않고 코드의 실행 흐름을 복구시킬 수 있다. throw된 에러를 어디에서도 캐치하지 않으면 프로그램은 종료된다. 주의할 것은 비동기 함수인 setTimeout이나 프로미스 후속 처리 메서드의 콜백함수는 호출자가 없다는 것이다. 콜백함수는 이벤트 루프에 의해 콜 스택이 비어지는 순간에 push되므로 콜백 함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재하게 된다. 이는 에러를 전파할 호출자가 없다는 것을 의미한다.","link":"/2023/01/15/230114-js-error%EC%B2%98%EB%A6%AC/"},{"title":"23년 1월 4주차 주간회고","text":"주간 회고 (22.01.18 ~ 23.01.24) 한 주간 배운점, 느낀점, 보완해야할 점을 keyword 중심으로 나열합니다. 배운점 JavaScript 정규표현식 패스트 캠퍼스 정규 표현식 part 완강, 사용해본 메서드, 패턴, 플래그 정리하여 이전 포스팅 업데이트 관련 포스팅 보러가기 느낀점 핵심을 잡고 그것을 해내려면 어떻게 접근해야하는지 고민 (결과물로부터 역추적) 어려움이 있다면 쪼개어서 생각해보기. (Divide &amp; Conquer !) 복잡하다면 단순화해서 쉬운 부분부터 정복해 나가기.(Simplify !) 러버덕에게 왜 안되는 건지 물어보자.. 잘 안되는 건 stack overflow에 검색하자. 보완해야할 점 지난 보완점 Feedback 로직은 내가 관리하게 될 변수와, 변수의 스코프를 항상 염두에 두고 짜자. 구체적으로 어떤 식으로 바라볼지 감이 안 잡힌다. 실력이 많이 부족함.. 함수는 그 기능을 보다 명확하고 간결하게 짜도록 노력하자. 프로젝트를 단순히 기능만 구현한 상태로 끝내지말고 리팩토링과 기능 추가를 더해보자 생각한대로 기능이 작동하지 않는다면, debugging을 통해 변수의 상태와 스코프, 스택을 눈으로 직접 확인하는 과정을 거치자. To Do TIL을 정리하든, 회고를 작성하든 글을 씁시다. 지난 한 주간 글을 너무 안 썼다. layout을 보는 눈이 아직 많이 부족한 것 같다. 매일 조금씩이라도 연습하자. 생각하던대로 생각하는 것이 아닌지, 하던 것만 하는 것이 아닌지. 한 번씩 돌아볼 필요가 있어 보인다. 실력이 부족하여 어려움은 겪을 수 있지만, 절대 사고가 정체되어선 안될 것.","link":"/2023/01/25/wil-2301-4th/"},{"title":"브라우저 저장소 종류 4가지","text":"저장소 종류 4가지1. localStorage 키, 밸류 저장소 가볍게 사용하기 좋은 대신, 기능이 많지 않다. 키, 밸류는 스트링 타입만 최대 저장 용량이 많지 않다. 보통 5~10MB 데이터를 만료기간 없이 계속 저장 가능. 지원하는 메소드 setItem(“key”, “value”) getItem(“key”) removeItem(“key”) clear() 2. sessionStorage 브라우저를 종료하거나 새 탭을 열 때 저장소가 초기화됨. 같은 탭에서 새로고침될 때는 데이터가 그대로 보존됨. 용도 : 에디터의 자동 임시 저장 지원하는 메소드 setItem(“key”, “value”) getItem(“key”) removeItem(“key”) clear() 3. IndexedDB 이름에서부터 DB를 사용하는만큼, 다양한 기능을 제공. 상대적으로 저수준 API를 제공하기 때문에 가볍게 사용하기엔 까다로울 수 있다. 4. Cookie 저장 가능한 용량은 4KB정도로 작다. 서버 데이터를 공유하는 용도로 사용됨. 서버에 요청을 보낼 때 함께 보내지게 되는 쿠키가 MB 단위가 된다면 문제가 될 수 있다. localStorage와 다르게 데이터 유효 기간을 지정할 수 있다. 특히 서버 사이드 렌더링을 할 때 더 빛을 발한다. localStorage에 담겨있는 데이터를 서버 단에서 알 방법이 없는데, Cookie에 서버에서 사용될 데이터를 미리 담아놓는다면, 서버 단에서 html을 렌더링할 때 더욱 많은 정보를 담아낼 수 있다. 이는 곧 로딩 시간 단축을 의미.","link":"/2023/01/29/230129-js-storage/"},{"title":"SPA와 Routing","text":"SPA와 Routing 본 Repo는 이웅모님의 웹사이트 poiemaweb의 포스팅 SPA &amp; Routing에 100% 의존하고 있습니다. 김상헌 멘토님의 추천으로 해당 포스팅을 접했고, 포스팅에 소개되어있는 소스코드가 인상 깊어서 백지부터 소스코드를 짜보며 SPA와 Routing에 대한 이해를 높히고자 함에 그 목적이 있습니다. SPA &amp; Routing 포스팅의 내용을 키워드 중심으로 나열하여 다시 봤을 때 효과적으로 상기시킬 수 있도록 합니다. SPA란 ?기존 link tag를 통한 화면 전환 방식의 단점 새로운 페이지 요청 시마다 정적 리소스 다운로드 전체 페이지를 리렌더링 : 새로고침 현상 SPA의 장점 ajax를 통한 트래픽 감소 웹 애플리케이션에 필요한 모든 정적 리소스를 최초 접근 시 단 한번 다운로드 이후 ajax 통신을 통해 변경된 부분만 갱신 사용자 경험(UX) 향상 새로고침 현상 제거 SPA의 단점(trade-off) 초기 구동 속도가 느리다. SEO(검색 엔진 최적화) 이슈 SPA방식에서 사용되는 CSR(Client Side Rendering) CSR방식은 일반적으로 데이터 패치 요청을 통해 서버로부터 데이터를 응답받아 뷰를 동적으로 생성. 이 때 브라우저 주소창의 URL이 변경되지 않고 이는 곧, 브라우저의 History를 관리할 수 없음을 의미한다. Routing 이란 ? Routing 라우팅이란, 출발지에서 목적지까지의 경로를 설정하는 기능 애플리케이션에서의 라우팅은 User가 Task를 수행하기 위해 어떤 화면(View)에서 다른 화면으로 화면을 전환하는 내비게이션 관리를 위한 기능을 의미. 일반적으로 라우팅은 사용자가 요청한 URL 또는 이벤트를 해석하고 새로운 페이지로 전환하기 위해 필요한 데이터를 서버에 요청하고 페이지를 전환하는 일련의 행위를 말함. 브라우저에서 화면을 전환하는 경우 브라우저의 주소창에 URL을 입력 웹페이지의 링크(a 태그)를 클릭 브라우저의 뒤로가기 또는 앞으로가기 버튼을 클릭(사용자 방문기록 - history 기반) history 관리를 위해서는 각 페이지는 구별할 수 있는 고유한 URL을 소유해야한다. SPA와 Rounting 살펴볼 케이스는 총 4가지이다. 전통적 링크 방식 (link) ajax ajax + hash ajax + pushState(pjax) 각각의 소스코드를 해석해보고, 각 방식이 가지는 trade-off를 알아보자. Routing 방식 4가지1. link1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;SPA-Router - Link&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/service.html&quot;&gt;Service&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about.html&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;p&gt;This is main page&lt;/p&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; a tag의 href 속성값인 리소스 경로가 URL의 path에 추가되고 해당 리소스를 서버에 요청한다. 서버는 리소스를 클라이언트에 응답(서버 사이드 렌더링(SSR)). 브라우저는 서버가 응답한 html을 렌더링하게 되므로 새로고침이 발생. 각 페이지마다 고유의 URL이 존재하므로 history 관리 및 SEO 대응에 아무런 문제가 없다. 하지만 요청마다 중복된 리소스를 응답받아야 하며 전체 페이지를 다시 렌더링하는 과정에서 새로고침이 발생 2. ajax1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;SPA-Router - ajax&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;script type=&quot;module&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul id=&quot;navigation&quot;&gt; &lt;!-- a href 속성값으로 서버 측에서 미리 정의한(약속된) endpoint를 사용한다. --&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/service&quot;&gt;Service&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div id=&quot;root&quot;&gt;Loading...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ajax 방식은 내비게이션 클릭 이벤트를 캐치하고 사전에 서버로의 요청을 방지한다. 후에 href 속성값으로 명시된 path를 추출하여 ajax 요청을 실시한다. 12345678910111213141516171819202122232425262728293031323334import { Home, Service, About, NotFound } from &quot;./components.js&quot;;const navigationEl = document.getElementById(&quot;navigation&quot;);const rootEl = document.getElementById(&quot;root&quot;);const routes = [ { path: &quot;/&quot;, component: Home }, { path: &quot;/service&quot;, component: Service }, { path: &quot;/about&quot;, component: About },];async function render(path) { try { // path에 맞는 컴포넌트 반환 const component = routes.find((route) =&gt; route.path === path)?.component ?? NotFound; // 만들어진 컴포넌트를 html root요소에 삽입 rootEl.replaceChildren(await component()); } catch (error) { console.error(error); }}// ajax 요청은 주소창의 url을 변경시키지 않으므로 history 관리가 되지 않는다.navigationEl.addEventListener(&quot;click&quot;, (event) =&gt; { if (!event.target.matches(&quot;#navigation &gt; li &gt; a&quot;)) return; event.preventDefault(); const path = event.target.getAttribute(&quot;href&quot;); render(path);});// 주소창의 url이 변경되지 않기 때문에 새로고침 시 현재 렌더링된 페이지가 아닌 루트 페이지가 요청된다.window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; render(&quot;/&quot;)); 123456789101112131415161718192021222324252627// components.jsconst createElement = (domString) =&gt; { const tplEl = document.createElement(&quot;template&quot;); tplEl.innerHTML = domString; return tplEl.content;};const fetchData = async (url) =&gt; { const res = await fetch(url); const json = await res.json(); return json;};// 컴포넌트 반환 함수export const Home = async () =&gt; { const { title, content } = await fetchData(&quot;/api/home&quot;); return createElement(`&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`);};export const Service = async () =&gt; { const { title, content } = await fetchData(&quot;/api/service&quot;); return createElement(`&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`);};export const About = async () =&gt; { const { title, content } = await fetchData(&quot;/api/about&quot;); return createElement(`&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`);};export const NotFound = async () =&gt; createElement(`&lt;h1&gt;404 Not Found&lt;/h1&gt;`); ajax 요청은 주소창의 URL을 변경시키지 않는다. 브라우저의 뒤로가기, 앞으로가기 등의 history 관리가 동작하지 않음을 의미. 따라서 history.back(), history.go(n) 등도 동작하지 않는다. 주소창의 URL이 변경되지 않기 때문에 새로고침을 해도 언제나 첫 페이지가 다시 로딩된다. 동일한 하나의 URL로 동작하는 ajax 방식은 SEO 이슈에서도 자유로울 수 없다. 3. ajax + hash ajax 방식은 불필요한 리소스 중복 요청을 방지할 수 있고 새로고침이 없는 사용자 경험을 구현할 수 있다는 장점이 있지만 history 관리가 되지 않는 단점이 있다. 이를 보완한 방법이 Hash 방식이다. Hash 방식은 URI의 fragment identifier(#service)의 고유 기능인 앵커(anchor)를 사용한다. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;SPA-Router - Hash&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;script type=&quot;module&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul id=&quot;navigation&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#service&quot;&gt;Service&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div id=&quot;root&quot;&gt;Loading...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; URL이 동일한 상태에서 hash만 변경되면 브라우저는 서버에 어떠한 요청도 하지 않는다. 즉, 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않는다. hash는 요청을 위한 것이 아니라 fragment identifier(#service)의 고유 기능인 앵커(anchor)로 웹페이지 내부에서 이동을 위한 것이기 때문이다. hash 방식은 페이지마다 고유의 논리적 URL이 존재하므로 history 관리에 아무런 문제가 없다. 123456789101112131415161718192021222324252627import { Home, Service, About, NotFound } from &quot;./components.js&quot;;const rootEl = document.getElementById(&quot;root&quot;);const routes = [ { path: &quot;&quot;, component: Home }, { path: &quot;service&quot;, component: Service }, { path: &quot;about&quot;, component: About },];const render = async () =&gt; { try { // url의 hash 정보 추출 const hash = window.location.hash.replace(&quot;#&quot;, &quot;&quot;); const component = routes.find((route) =&gt; route.path === hash)?.component ?? NotFound; rootEl.replaceChildren(await component()); } catch (err) { console.error(err); }};// url의 hash가 변경하면 발생하는 이벤트인 `hashchange` 이벤트를 사용하여 hash의 변경을 감지하여 필요한 ajax 요청을 수행.window.addEventListener(&quot;hashchange&quot;, render);// render 함수는 url의 hash를 취득해 새로고침 직전에 렌더링되었던 페이지를 다시 렌더링.window.addEventListener(&quot;DOMContentLoaded&quot;, render); 또 다른 문제는 SEO 이슈이다. 웹 크롤러는 검색 엔진이 웹사이트의 콘텐츠를 수집하기 위해 HTTP와 URL 스펙(RFC-2396같은)을 따른다. 이러한 크롤러는 JavaScript를 실행시키지 않기 때문에 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다. 구글은 해시뱅을 일반적인 URL로 변경시켜 이 문제를 해결한 것으로 알려져 있지만 다른 검색 엔진은 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없을 수도 있다. 4. ajax + pushState (pjax) hash 방식의 가장 큰 단점은 SEO 이슈이다. 이를 보완한 방법이 HTML5의 History API인 pushState와 popstate 이벤트를 사용한 pjax(pushState + ajax) 방식이다. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;SPA-Router - Pjax&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;script type=&quot;module&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul id=&quot;navigation&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/service&quot;&gt;Service&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div id=&quot;root&quot;&gt;Loading...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 내비게이션 클릭 이벤트를 캐치하고 preventDefault 메서드를 사용해 서버로의 요청을 방지한다. 이후, href 속성값 path을 사용하여 ajax 요청을 하는 방식. ajax 요청은 브라우저 주소창의 URL을 변경시키지 않아 history 관리가 불가능하다. 이때 사용하는 것이 pushState 메서드이다. pushState 메서드는 주소창의 URL을 변경하고 URL을 history entry로 추가하지만 서버로 HTTP 요청을 하지는 않는다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import { Home, Service, About, NotFound } from &quot;./components.js&quot;;const navigationEl = document.getElementById(&quot;navigation&quot;);const rootEl = document.getElementById(&quot;root&quot;);const routes = [ { path: &quot;/&quot;, component: Home }, { path: &quot;/service&quot;, component: Service }, { path: &quot;/about&quot;, component: About },];const render = async (path) =&gt; { // 새로고침 혹은 앞으로 가기/ 뒤로가기 시 path값을 처리하기 위해 _path 변수를 통해 상태 관리를 한다. const _path = path ?? window.location.pathname; try { const component = routes.find((route) =&gt; route.path === _path)?.component || NotFound; rootEl.replaceChildren(await component()); } catch (err) { console.error(err); }};navigationEl.addEventListener(&quot;click&quot;, (event) =&gt; { if (!event.target.matches(&quot;#navigation &gt; li &gt; a&quot;)) return; event.preventDefault(); const path = event.target.getAttribute(&quot;href&quot;); // 이동할 페이지가 현재 페이지와 같다면 함수 종료 if (window.location.pathname === path) return; window.history.pushState(null, null, path); render(path);});window.addEventListener(&quot;popstate&quot;, () =&gt; { render();});/** * 웹페이지가 처음 로딩되면 window.location.pathname를 확인해 페이지를 이동시킨다. * 새로고침을 클릭하면 현 페이지(예를 들어 localhost:5004/service)가 서버에 요청된다. * 이에 응답하는 처리는 서버에서 구현해야 한다. */window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; { render();}); history.pushState 메서드는 주소창의 url을 변경하지만 HTTP 요청을 서버로 전송하지 않는다. 페이지마다 고유의 URL이 존재하므로 history 관리가 가능하다. hash를 사용하지 않으므로 SEO에도 문제가 없다. 주의할 점은, 브라우저의 새로고침 버튼을 클릭하면 pjax 방식은 pushState로 바뀐 주소창의 URL 경로로 서버에 요청을 보내기 때문에 이에 대한 처리가 필요하다. 즉, pjax 방식은 서버 렌더링 방식과 ajax 방식이 혼재되어 있는 방식으로 서버의 지원이 필요하다. 이에 대한 서버 구현은 다음과 같다. 12345678910111213141516171819202122const express = require(&quot;express&quot;);const path = require(&quot;path&quot;);const app = express();const port = 5004;app.use(express.static(path.join(__dirname, &quot;public&quot;)));app.get(&quot;/api/:page&quot;, (req, res) =&gt; { const { page } = req.params; res.sendFile(path.join(__dirname, `data/${page}.json`));});// 페이지 새로고침을 위한 처리// 브라우저 새로고침 시 서버는 index.html을 전달하고 클라이언트는 window.location.pathname를 참조해 다시 라우팅한다.app.get(&quot;*&quot;, (req, res) =&gt; { res.sendFile(path.join(__dirname, &quot;public/index.html&quot;));});app.listen(port, () =&gt; { console.log(`Listening on https:/localhost:${port}`);}); 결론 구분 History 관리 SEO 대응 사용자 경험 서버 렌더링 구현 난이도 IE 대응 link 방식 ◯ ◯ ✗ ◯ 간단 ajax 방식 ✗ ✗ ◯ ✗ 보통 7 이상 ajax + hash 방식 ◯ ✗ ◯ ✗ 보통 8 이상 pjax 방식 ◯ ◯ ◯ △ 복잡 10 이상","link":"/2023/01/28/230128-spa-routing/"},{"title":"TIL 230131 javascript","text":"메모리 누수 예제불필요한 전역 객체 예를 들어 브라우저 환경에서 window 객체를 없애지 않는 이상 전역에 등록된 변수는 계속 살아 남는다. 수동으로 null을 할당하면 가비지 컬렉터의 수집을 유도할 수 있다. 분리된 노드 참조 예제123456&lt;button&gt;Remove!&lt;/button&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;2&lt;/div&gt;&lt;/div&gt; 1234567const btn = document.querySelector(&quot;button&quot;);const parent = document.querySelector(&quot;.parent&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; { console.log(parent); // &lt;div class=&quot;parent&quot;&gt;...&lt;/div&gt; parent.remove();}); html의 요소와 js의 parent 변수에 할당되어있는 값은 별개. 따라서 화면상 요소를 지우더라도 변수에 할당되어 있는 값은 여전히 유지됨. 1234567const btn = document.querySelector(&quot;button&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; { const parent = document.querySelector(&quot;.parent&quot;); console.log(parent); // &lt;div class=&quot;parent&quot;&gt;...&lt;/div&gt; parent &amp;&amp; parent.remove();}); parent를 찾아 변수에 할당하는 행위를 지역 스코프 안에 넣어줌으로써 해결 해제되지 않은 타이머잘못된(무분별한) 클로저 사용리플로우와 리페인트 리플로우 : 브라우저가 painting을 위해 계산하는 행위(브라우저 화면에 무엇인가 출력하기 위해, 크기나 위치 등을 계산하는 과정) 리페인트 : 다시 화면에 그리는 작업 리플로우는 비용이 많이 드는 작업이다. 노드의 크기, 여백, 위치 등 주변 노드에 영향을 주는 레이아웃 속성이 변경되면, 브라우저는 모든 노드를 리플로우하고 영향을 받은 모든 화면 영역을 다시 리페인트합니다. 노드의 visibillty, outline, opacity, transform, filter, box-shadow, background-color, color 등, 주변 노드에 영향을 주지 않는 단순 표시 속성이 변경되면, 브라우저는 리플로우 없이 해당 노드만 리페인트합니다. absolute를 주고 margin값을 변경해도 리플로우는 발생함. 기타 GSAP 라이브러리 (애니메이션 관련)","link":"/2023/02/02/til-230131-js/"}],"tags":[{"name":"error","slug":"error","link":"/tags/error/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"etc","slug":"etc","link":"/tags/etc/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"},{"name":"국비지원교육","slug":"국비지원교육","link":"/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EA%B5%90%EC%9C%A1/"},{"name":"메가바이트스쿨","slug":"메가바이트스쿨","link":"/tags/%EB%A9%94%EA%B0%80%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%8A%A4%EC%BF%A8/"},{"name":"MegabyteSchool","slug":"MegabyteSchool","link":"/tags/MegabyteSchool/"},{"name":"개발자취업부트캠프","slug":"개발자취업부트캠프","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/"},{"name":"내일배움카드","slug":"내일배움카드","link":"/tags/%EB%82%B4%EC%9D%BC%EB%B0%B0%EC%9B%80%EC%B9%B4%EB%93%9C/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"clone","slug":"clone","link":"/tags/clone/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"scss","slug":"scss","link":"/tags/scss/"},{"name":"parcel","slug":"parcel","link":"/tags/parcel/"}],"categories":[{"name":"html&#x2F;css","slug":"html-css","link":"/categories/html-css/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"error","slug":"error","link":"/categories/error/"},{"name":"Weekly Recap","slug":"Weekly-Recap","link":"/categories/Weekly-Recap/"},{"name":"wil","slug":"wil","link":"/categories/wil/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"algorithm","slug":"javascript/algorithm","link":"/categories/javascript/algorithm/"},{"name":"bundler","slug":"bundler","link":"/categories/bundler/"}],"pages":[]}