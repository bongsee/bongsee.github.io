{"posts":[{"title":"(Error) git init으로 프로젝트 시작하기 vs git clone으로 프로젝트 시작하기","text":"상황 설명 로컬에서 hexo blog framework로 blog 구축 project를 시작함. github에서 github blog 생성하기 위해 repo 생성. 위의 원격 repo에 hexo-deployer-git plugin을 사용하여 deploy함. hexo project에서 static file들은 public폴더에서 관리하므로, git으로 버전 관리를 하기 위해 public 폴더에 git init 시전. 에러 메세지들 123$ git push origin mainerror: src refspec main does not match anyerror: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git' remote에는 master branch가 없기 때문에 출력된 에러 메세지 123456789$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (fetch first)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. remote에 있는 것들이 당연하게 내 local에도 있어야 하는데, 없으니까 일단 pull로 땡겨와라. 라는 메세지 12345678910$ git pull origin mainremote: Enumerating objects: 46, done.remote: Counting objects: 100% (46/46), done.remote: Compressing objects: 100% (27/27), done.remote: Total 46 (delta 9), reused 46 (delta 9), pack-reused 0Unpacking objects: 100% (46/46), 129.91 KiB | 601.00 KiB/s, done.From https://github.com/bongsee/bongsee.github.io * branch main -&gt; FETCH_HEAD * [new branch] main -&gt; origin/mainfatal: refusing to merge unrelated histories 관련 없는 기록 병합 거부 remote의 commit history와 local의 commit history가 관련성이 없기 때문에 merge하는데 실패하는 것 기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit지점이 존재해야 한다.그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit이 없기때문에 pull 명령어를 사용할 수 없는 것이다. 12345678$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (non-fast-forward)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 힌트 : 현재 지점의 끝이 원격 지점 뒤에 있기 때문에 업데이트가 거부되었습니다. 다시 푸시하기 전에 원격 변경 사항을 통합하십시오. rejected : push가 거부되었다. master -&gt; master : 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 했는데 non-fast-forward : 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다. 라는 의미이다. 그럼 git push는 내부적으로 어떻게 할지말지를 판단하나 ? push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다.그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 정리 애초에 접근부터가 잘못됐다. (git clone)원격 repo에서 프로젝트를 시작했으면, 해당 repo를 clone해와서 repo와 local을 동기화시킨 이후에 작업을 해야하는 것이고, (git init)local에서 프로젝트를 시작했으면, remote에 대한 설정과 upstream 링크를 걸어주는 등의 작업을 직접해야하는 것이다. 결론은 어쨌든 연결되는 공통된 커밋 포인트가 없다는 것. 아~ 최우영 강사님,, 이제야 깨닫습니다. 왜 remote에서 시작해서 clone하는게 편한지요… Refs https://jobc.tistory.com/177","link":"/2022/12/19/221219_error_git/"},{"title":"Data Format에 대해","text":"Data Format (22.12.17)Focus 데이터 포맷이 왜 필요할까 ? JSON YAML 데이터 직렬화/역직렬화 1. 데이터 포맷이 왜 필요할까 ? 혼자 개발하거나, 내부적으로 데이터를 사용할 땐 내부의 규칙을 문서화하고 참고하면 그만이지만, 문제는 타인 또는 타 시스템과 연동을 해야할 때다. 데이터를 주고 받을 때 마다 각자 정해진 규칙을 문서로 주고 받는 것도 비효율적이고, 하나의 통일된 규칙이 없을 때 생기는 불필요한 문서들이 많아지기 마련임. 이렇게 상호가 데이터를 효율적으로 다루고자 통일된 규칙을 가지는 ‘format’이 등장하게 된다. XML, JSON, YAML 등이 있다. 2. JSON JSON 데이터 포맷 예시1234567891011121314151617181920212223242526272829303132{ &quot;name&quot;: &quot;Rust&quot;, &quot;on&quot;: { &quot;push&quot;: { &quot;branches&quot;: [&quot;master&quot;] }, &quot;pull_request&quot;: { &quot;branches&quot;: [&quot;master&quot;] } }, &quot;env&quot;: { &quot;CARGO_TERM_COLOR&quot;: &quot;always&quot; }, &quot;jobs&quot;: { &quot;build&quot;: { &quot;runs-on&quot;: &quot;ubuntu-latest&quot;, &quot;steps&quot;: [ { &quot;uses&quot;: &quot;actions/checkout@v2&quot; }, { &quot;name&quot;: &quot;Build&quot;, &quot;run&quot;: &quot;cargo build --verbose&quot; }, { &quot;name&quot;: &quot;Run tests&quot;, &quot;run&quot;: &quot;cargo test --verbose&quot; } ] } }} 데이터 직렬화에 유리하여 일반적으로 데이터 전송, AJAX 통신 등 API 통신에 주로 사용됨. XML은 헤더와 태그 등으로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 있었던 데 반해 JSON은 나은 가독성, 효율성을 가진다. 주석을 지원하지 않는다. 데이터 타입을 강제하려면 JSON 스키마로 보완해야한다. 3. YAML YAML 데이터 포맷 예시123456789101112131415161718#!syntax yamlname: Ruston: push: branches: [master] pull_request: branches: [master]env: CARGO_TERM_COLOR: alwaysjobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Build run: cargo build --verbose - name: Run tests run: cargo test --verbose​ 주로 수정이 잦은 설정(conf) 파일에 사용됨. XML, JSON 보다 직관적이라 가독성이 좋다. 주석이 가능하다. 데이터 타입을 명시해줄 수 있다. 데이터 직렬화가 불편하다. 4. 데이터 직렬화/역직렬화 : (보완, 수정 요 - 운영체제) 직렬화(Serialization)란, 참조 타입의 데이터를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형태로 변환하는 작업임. 역직렬화(Deserialization)란, 디스크에 저장된 데이터를 읽거나, 네트워크를 통해 전송받은 데이터를 메모리에 저장하기 위한 형태로 변환하는 작업임. 메모리에서 데이터가 가지는 구조는 2가지다. 값(Value) 형식 데이터 참조(Reference) 형식 데이터 : 객체 타입이 여기에 해당. 이 두가지 데이터 중 디스크에 저장하거나 네트워크 통신을 할 수 있는 데이터는 값(Value) 형식의 데이터다. 직렬화를 통해 참조 형태의 데이터를 값 형태로 변환.","link":"/2022/12/19/221218_data_format/"},{"title":"Mark down 문법 정리(+ 업데이트 중)","text":"* 구분선--- * 텍스트 강조**강조될 텍스트** 강조될 텍스트 / 일반 텍스트 * 이미지 삽입![이미지 이름](이미지 주소) * 줄 바꿈엔터 두번 * 줄 여러번 바꾸기&lt;br&gt; 2022-12-24 추가 업데이트Markdown file에서 이미지 크기 조절하기 기존의 이미지 삽입과 다른 방식을 사용. img tag를 활용할 수 있다. &lt;img src=&quot;이미지 주소&quot; width=&quot;원하는 가로너비&quot; height=&quot;원하는 세로너비&quot;&gt; 2022-12-27 추가 업데이트들여쓰기 4개의 공백으로 들여쓰기가 가능하다.","link":"/2022/12/18/221218_markdown/"},{"title":"221219, 221220 TIL (html, css)","text":"박영웅 강사님의 html, css 강의 인상 깊었던 멘트 어떤 사이트를 클론할 땐 가장 먼저 해야할 것은 ‘구조화’이다. 모든 layout은 위에서 아래로 쌓인다. 세세한 수치는 개발자 도구에서 찾아서 쓰기 브라우저가 기본적으로 제공하는 값들이 존재한다. –&gt; 브라우저의 기본 셋팅값을 초기화 시킨 후 진행 css 속성들의 default 값을 먼저 알아라. 내가 직접 지정하지 않아도 설정되어있는 값을 아는 것이 먼저! 그 후에 제대로 된 조작이 가능! ‘검증’에 대한 고찰 어떤 코드를 검증하고자 할 땐 주변 코드를 배제시키고 백지에 검증하고자 하는 코드만 놓고 봐야한다. 그렇지 않으면 주변 코드에 의해 오염될 가능성이 높아지고, 검증의 신뢰도는 급격히 떨어짐. KeywordsHTML html 전역속성 DOCTYPE의 의미 data-xxx 속성 tabIndex, contenteditable 속성 HTML Entity 그럼에도 불구하고 Semantic tag를 지향해야하는 이유 CSS vector image / bitmap image scss / css framework / css in js viewport image sprite CSS 선택자 종류 inline element / block element inline요소는 본질적으로 layout을 다루기 위한 것이 아닌, 글자를 제어하기 위한 용도이다. 따라서 inline 요소는 너비값인 width와 height 속성을 부여해도 동작하지 않는다. width와 height의 default : auto &amp; 그 의미 CSS 선택자 읽는 법 가상 클래스 선택자 / 가상 요소 선택자 CSS 상속 상속이 되는 속성 postion : absolute에 대한 고찰 강제 상속 inherit 선택자 명시도 box-sizing : border-box etc cross browsing Emmet 문법","link":"/2022/12/22/221219-htmlcss/"},{"title":"(프로그래머스 lv0) 두수의 나눗셈 알고리즘 풀이","text":"문제 설명 정수 num1과 num2가 매개변수로 주어질 때, num1을 num2로 나눈 값에 1,000을 곱한 후 정수 부분을 return 하도록 soltuion 함수를 완성해주세요. 제한사항 0 ≤ num1 ≤ 100 0 ≤ num2 ≤ 100 입출력 예 num1 num2 result 3 2 1500 7 3 2333 1 16 62 입출력 예 설명 입출력 #1 : num1이 3, num2가 2이므로 3 / 2 = 1.5에 1,000을 곱하면 1500이 됩니다. 입출력 #2 : num1이 7, num2가 3이므로 7 / 3 = 2.33333…에 1,000을 곱하면 2333.3333…. 이 되며, 정수 부분은 2333입니다. 나의 풀이12345function solution(num1, num2) { let answer = 0; answer = Math.floor((num1 / num2) * 1000); return answer;} 회고 연산자 우선순위를 고려하면 다음의 코드를 수정할 수 있겠다. 곱하기, 나누기, 나머지 연산자는 같은 레벨의 우선순위를 가지며, 좌결합성의 연산자이다. (num1 / num2) * 1000 -&gt; num1 / num2 * 1000 즉, 괄호는 불필요함. 다만, 가독성을 고려하면 개인적으로 전자가 코드의 의도를 읽기 쉬워보임. 연산자 우선순위 ref","link":"/2022/12/22/221221-algo-%EB%91%90%EC%88%98%EC%9D%98%EB%82%98%EB%88%97%EC%85%88/"},{"title":"(프로그래머스 lv0) 분수의 덧셈 알고리즘 풀이","text":"문제 설명 첫 번째 분수의 분자와 분모를 뜻하는 denum1, num1, 두 번째 분수의 분자와 분모를 뜻하는 denum2, num2가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 &lt; denum1, num1, denum2, num2 &lt; 1,000 입출력 예 denum1 num1 denum2 num2 result 1 2 3 4 [5, 4] 9 2 1 3 [29, 6] 입출력 예 설명 입출력 #1 : 1 / 2 + 3 / 4 = 5 / 4입니다. 따라서 [5, 4]를 return 합니다. 입출력 #2 : 9 / 2 + 1 / 3 = 29 / 6입니다. 따라서 [29, 6]을 return 합니다. 나의 풀이1234567891011function solution(denum1, num1, denum2, num2) { let denum = denum1 * num2 + denum2 * num1; // 통분 후의 분자 let num = num1 * num2; // 통분 후의 분모 let divider; // 추가적으로 나눠야 하는가 ? 최대공약수 구하기 for (let i = 1; i &lt;= Math.min(denum, num); i++) { if (denum % i === 0 &amp;&amp; num % i === 0) { divider = i; } } return [denum / divider, num / divider];} 회고 최대공약수라는 개념을 아예 잊고 지냈는데, 다시 만나니까 반갑지 않다.","link":"/2022/12/22/221222-algo-%EB%B6%84%EC%88%98%EC%9D%98%EB%8D%A7%EC%85%88/"},{"title":"(프로그래머스 lv0) 최빈값 구하기 알고리즘 풀이","text":"문제 설명 최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다. 제한사항 0 &lt; array의 길이 &lt; 100 0 ≤ array의 원소 &lt; 1000 입출력 예 array result [1,2,3,3,3,4] 3 [1,1,2,2] -1 [1] 1 입출력 예 설명 입출력 #1 : [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다. 입출력 #2 : [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다. 입출력 #3 : [1]에는 1만 있으므로 최빈값은 1입니다. 나의 풀이12345678910111213141516171819202122232425function solution(array) { let numObj = {}; let max = 0; let answer = -1; // numObj 객체에 배열의 각 요소별 개수 정보를 입력 for (let num of array) { numObj[num] ? (numObj[num] += 1) : (numObj[num] = 1); } // 가장 높은 빈도수를 max에 할당 for (let key in numObj) { max = Math.max(max, numObj[key]); } // max 빈도수를 가진 요소를 출력 for (let key in numObj) { // max 빈도수가 중복이라면 -1 반환 if (numObj[answer] === numObj[key]) { return -1; } // max 빈도수값을 가지는 요소를 반환 if (numObj[key] === max) { answer = parseInt(key); } } return answer;} 회고 객체의 key값은 항상 타입이 문자열임을 잊지말자. 분명 더 쉬운 방법이 있을 것 같은데 다시 한번 들춰봐야할 것 같다.","link":"/2022/12/22/221222-algo-%EC%B5%9C%EB%B9%88%EA%B0%92%EA%B5%AC%ED%95%98%EA%B8%B0/"},{"title":"(프로그래머스 lv0) 옷가게 할인받기 알고리즘 풀이","text":"문제 설명 머쓱이네 옷가게는 10만 원 이상 사면 5%, 30만 원 이상 사면 10%, 50만 원 이상 사면 20%를 할인해줍니다.구매한 옷의 가격 price가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요. 제한사항 10 ≤ price ≤ 1,000,000 price는 10원 단위로(1의 자리가 0) 주어집니다. 소수점 이하를 버린 정수를 return합니다. 입출력 예 price result 150,000 142,500 580,000 464,000 입출력 예 설명 입출력 #1 : 150,000원에서 5%를 할인한 142,500원을 return 합니다. 입출력 #2 : 580,000원에서 20%를 할인한 464,000원을 return 합니다. 나의 풀이1234567891011121314function solution(price) { const level1 = 1 - 0.05; const level2 = 1 - 0.1; const level3 = 1 - 0.2; if (price &gt;= 500_000) { return Math.floor(price * level3); } else if (price &gt;= 300_000) { return Math.floor(price * level2); } else if (price &gt;= 100_000) { return Math.floor(price * level1); } else { return price; }} 회고 조건이 여러개 달리기 때문에 switch문을 사용해보면 어떨까했다. switch문의 case 뒤에 오는 건 조건이 아니라 값이다. 즉, 조건이 와버리면 값으로 평가해버리기 때문에 Boolean 값으로 자동 형변환이 진행된다. 또한 switch문은 기준이 되는 값과 case뒤에 오는 값의 일치여부(일치 연산자 ===)를 보기 때문에 아래의 코드는 내 의도와는 다르게 동작할 수 있다. 1234567891011121314function solution(price) { const level1 = 0.05; const level2 = 0.1; const level3 = 0.2; switch (price) { case price &gt;= 500_000: // &quot;price가 price &gt;= 500_000이라면&quot; 으로 해석이 되는 것이 아니라, 'price &gt;= 500_000'는 Boolean값으로 평가되기 때문에 'price === true라면', 또는 'price === false 라면' 으로 해석되는 것. return price * (1 - level3); case price &gt;= 300_000: return price * (1 - level2); case price &gt;= 100_000: return price * (1 - level1); }} swicth문은 case 뒤에 오는 값을 하나로 특정지을 수 있고, 그 값을 기준값과 비교하려고 할 때 써야할 것 같다. 논외로 switch문 사용하면서 들었던 의문을 정리해본다. 함수 내부의 switch문에서 반복문의 종료로 return을 사용할 수 있다. 다만 break는 switch문만을 탈출하고 함수 내부의 흐름으로 넘어가는 반면, return을 사용할 경우 switch문을 탈출하는 것 뿐 아니라, switch문이 위치해있던 함수도 종료함으로써 함수를 호출했던 context로 실행 흐름이 넘어간다.","link":"/2022/12/24/221224-algo-%EC%98%B7%EA%B0%80%EA%B2%8C%ED%95%A0%EC%9D%B8%EB%B0%9B%EA%B8%B0/"},{"title":"221223 TIL (html, css)","text":"박영웅 강사님의 html, css 강의이 포스트는 heropy blog의 post를 참조합니다. 인상 깊었던 멘트 정렬과 배치는 다른 개념이다. margin : auto는 배치를 하는 것이지 정렬의 개념이 아니라는 것. 명시적 !== 암시적 Flex 요소 Flex Container &amp; Flex item (각각에 적용할 수 있는 속성은 정해져있다.) Flex Container : display, flex-flow(flex-direction + flex-wrap), justify-content, align-content, align-items Flex item : order, align-self, flex(flex-grow, flex-shrink, flex-basis) Flex item 들은 block 요소처럼 동작하지만, 일반적인 block요소와는 다르게 width를 최대한 적게 가져간다. 추가적으로 강사님 블로그인 heropy blog에서 관련 공부 중에 display : flex와 display : inline-flex의 차이를 보여주는 그림에서 flex container와 flex item를 이해하는데 도움이 될 것 같은 그림을 퍼왔다. main axix &amp; cross axis / 시작점(start), 끝점(end) flex-direction에 따라 변화(상대적인 개념) 개별속성과 단축속성 간혹 단축속성에서 default값이 변화하는 부분이 발생하므로 주의하도록. 가급적 개별속성을 쓰는게 좋아보인다. Flex container의 정렬 속성에서 사용되는 단어의 의미 파헤치기 justify : main axis에 적용되는 정렬 align : cross axis에 적용되는 정렬 content : axis에 존재하는 줄이 여러개일 때 줄들 사이의 규칙을 적용할 때 사용. (2줄 이상) 예를 들어, flex container의 flex-direction이 row(default)일 때, flex-wrap : wrap 속성이 없다면 align-content 속성이 적용 안된다. (한 줄이기 때문에) items : axis에 존재하는 각각의 줄에 적용 (개별적용) space-xxx : 남는 공간/공백(space)를 어떻게 활용할 것 인가? 에 대한 속성 flex item의 정렬 속성에서 flex 속성 파헤치기 (item의 너비에 관한 속성)괄호 안은 해당 속성이 가지는 default 값 입니다. (default) flex item들은 한 줄 안에 모두 들어가려함. (flex-wrap : nowrap;) flex-grow (0) : item의 증가 너비 비율을 지정 (여기서 증가하는 부분은 main-axis방향으로, flex-direction에 따라 width가 될 수도, height가 될 수도.) flex-shrink (1) : item의 감소 너비 비율을 지정 (마찬가지.) flex-basis (auto) : item의 기본 너비 설정 auto : item의 content 너비를 제거한 공백 기준으로 계산 0 : content 너비를 포함한 계산 (우리가 보통 상상하는 그림이 이 값을 통해 나옴.) (주의)단축 속성으로 사용시 flex-basis의 default 값이 0으로 변화 Positionposition : static position의 기본값. position : absolute 적용된 요소는 자동으로 block요소로 동작한다. 주변과의 상호작용이 끊김. 위치 상의 부모를 찾는다. (없다면 viewport를 기준으로 동작) 위치 상의 부모를 지정해주기 위해 position : relative를 조상 요소 중 하나에 적용시킨다. (가급적 가까운 부모에 해주기) position : fixed 적용된 요소는 자동으로 block요소로 동작한다. 주변과의 상호작용이 끊김. viewport 기준으로 동작 (주의) transform, perspective, filter 의 속성 중 하나가 조상 요소 중에 적용이 되어있다면 해당 요소를 기준으로 동작함. 외울 필요는 없어보이고, fixed가 내 예상과는 달리 동작한다면 해당 케이스를 의심해볼 정도면 될 것으로 보인다. position : relative 자기 자신을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용 그러나, 위의 목적으로 쓰기에는 layout 해석 및 코드 유지보수의 관점에서 매우 불리해진다. relative는 주변과의 상호작용은 유지되면서 시각적으로 렌더링되는 위치만 옮겨지는 것이기 때문. (박영웅 강사님의 택배박스 neck slice 예시) transform : translate()으로 대체 가능. 그럼 어디에 쓰느냐 ? position : absolute가 적용된 요소의 기준점을 설정할 때 사용. position : sticky top, right, bottom, left의 값 중 하나 이상 적용이 되어야 동작한다. ETCbackground-image 속성 background-image : url() background-size : cover / contain cover : 이미지가 찌그러지지 않는 한도 내에서 제일 크게 설정. 이미지의 가로세로비가 요소와 다르다면 이미지를 세로 또는 가로방향으로 잘라내어 빈 공간이 생기지 않도록 설정. contain : 이미지가 잘리거나 찌그러지지 않는 한도 내에서 제일 크게 설정. background-repeat image 대체 텍스트 img 태그의 alt 속성 반드시 명시~ background-image 사용 시 text-indent : -9999px margin collapse 형제 요소 사이에서, margin-top과 margin-bottom이 만나면 큰 값이 작은 값을 덮어씀. 부모 요소의 top(bottom)과 자식요소의 top(bottom)이 만나면 발생. width : min-content linear-gradient 말줄임표 만들기 white-space : nowrap overflow : hidden text-overflow : ellipsis 색상값은 Hexadecimal code로 작성.","link":"/2022/12/24/221223-htmlcss/"},{"title":"CSS 기본값 정리(+ 업데이트 중)","text":"상속되는 속성들 글자와 관련된 속성 뿐!! 글꼴(5가지) line-height font-size font-weight font-family font-style 문자 color text-xxx 등등.. 그 외의 속성들은 강제 속성 inherit을 사용하여 속성값을 상속받을 수 있다. 기본값 정리 width : auto (해당 요소가 어떤 display 속성값을 가지느냐에 따라 다르게 동작함을 이해한다.) inline요소는 컨텐츠의 크기만큼만 가지도록 최대한 작은 값을 가짐. block요소는 부모 요소의 width만큼 최대한 늘어남. (주의) flex item이 되면 해당 item들은 block요소가 되지만, width는 최대한 줄어들으려한다. height : autoheight는 inline이든 width든 컨텐츠의 크기만큼만 가지도록 최대한 줄어들려한다. max-width / max-height : none min-width / min-height : 0 box-sizing : content-box color : inherit 대표적인 inline 요소들 a br button img input label select span ::before, ::after로 만든 가상요소도 inline으로 동작.","link":"/2022/12/24/221224-css-default-value/"},{"title":"221225 TIL 요약","text":"Clone 과제하면서 느꼈던 점 layout은 철저히 계획 하에 하자. 즉, CSS 작업이 들어갈 때 웹 페이지의 layout 박스들이 머릿 속에 그려져야 한다. 그만큼 layout에 대한 계획을 세부적으로 잘 세워놓을 수록 전체 작업 시간이 많이 줄어들고, 머릿속도 간결해짐. html구조는 가능하면 최소화한다. (중첩을 최소화해서 tree구조를 최대한 줄일 수록 좋을 듯하다.) 고려해볼 만한 점 : html구조를 만들지 않고 CSS로 처리할 수 있는 방안이 있는가? (예를 들어 ::before, ::after와 같은 가상 요소) BEM 네이밍 시 하위 구조가 2 depth 이상이 필요하다면, 컴포넌트가 분리되어야 한다는 신호다. (headr__nav__item) 일단 내 clone 과제는 depth가 2,3 이상 필요할 때도 많았고 심지어 내가 BEM을 쓰는 건지 뭘 쓰는건지 이젠 갈피도 못잡겠다. 네이밍 진짜 개어렵다ㅠ 회고 복잡할 수록 구조화하고 구조화 된 틀 안에서 쪼개어 생각하자.","link":"/2022/12/25/221225-css/"},{"title":"12월 5주차 주간 회고","text":"주간 회고 한 주간 배운점, 느낀점, 보완해야할 점을 keyword 중심으로 나열합니다. 배운점 CSS CSS를 바라보는 틀을 잡다. CSS는 크게 Layout을 잡는 속성과 그 외의 속성으로 바라볼 수 있다. 예를 들어, layout을 잡는 용도의 block요소와 글자를 다루기 위한 inline요소가 있겠다. CSS의 각 속성은 default값이 무엇인가?부터 시작한다. 내가 명시적으로 지정하지 않아도 암묵적으로 적용되고 있는 속성들이 존재한다는 것을 안다. 검증이 필요할 땐 백지에서 시작한다. 주변의 코드로부터 오염되는 것을 방지하기 위해. CSS 선택자를 읽고 해석하는 방법 CSS는 웹 표준으로, legacycode가 잔존한다는 것을 이해한다. 상속이 되는 속성은 정해져있다. 개별속성과 단축속성 속성값이 절대적인 값인가? 혹은, 기준이 필요한 상대적인 값인가? 배치와 정렬이 다름을 인지. position … 주변과의 상호작용이 끊기는가 ? 반응형 breakpoint에 따라 매번 새로 만드는 개념이 아님. 시안을 보고 가변적으로 동작하는 요소로 가능하다면 굳이 새로 모양을 잡을 필요가 없는 것. UI Framework에 대한 생각 쓸 때 좋을지, 아니면 유지보수를 최대한 고려할 지. 심사 숙고하여 도입하기 느낀점 이번 한 주는 1차 과제(웹페이지 클론코딩)을 하는데 전부를 보낸 것 같다. 우선 클론코딩하면서 지나갔던 생각들을 여기에 잡아놓아본다. 우선, layout에 관한 이야기다. section별로 layout을 잡고 코딩을 시작했는데, 어느 section은 layout을 가장 큰 단위로만 잡고 바로 코드를 짰고, 어느 section은 layout을 가장 최하위까지 구조화해서 들어갔다. 전자의 경우 코드를 짜다가 중간에 html구조를 추가하는 일이 빈번하게 발생했고, 그에 따라 CSS code 구조도 매번 새롭게 다시 짜야했기 때문에 시간은 시간대로 들이고, 머릿속은 그것대로 복잡해졌다. 결국 어찌저찌 구현은 했는데 기분은 마치 똥싸고 똥꼬 안닦은 느낌과 비슷했다. 일처리가 매끄럽지 못했기 때문이라고 생각한다. 후자의 경우 최대한 layout을 최하위까지 잡고 들어갔다. 그렇게 했더니 구조화된 틀 안에서 컴포넌트 별로 분리해서 생각할 수 있었고, 오히려 처음에 잡은 구조는 조금 더 복잡했지만(최하위 요소까지 고려해야했기 때문에) 머릿속은 한결 가벼웠고 결과적으로 쏟아 부은 시간도 적게 들었다. 또한 막히는 부분이 생기면, 어떻게 구현을 할 수 있을까? 또는 현재 구조에서 구현이 불가능하다면 layout에서 어떤 부분의 설계가 잘못되었는가? 와 같은 좀 더 발전적인 질문까지 던질 수 있었다. 결론은, 후자의 경우가 처음엔 느려보일지라도 결과적으로 훨씬 나은 선택일 수 있다는 것. layout에 대한 설계에 가장 많은 시간을 쏟아내자는 것이다. 흘러가는 지식들이 너무 많다. 배운 내용을 그때 그때 정리하는 편이다. 그러나 다시 들춰보지를 않으니 동일한 문제를 만날 때마다 검색하고 하는 일이 너무 빈번한 것 같다. 배운 내용을 정리하는 건 내 작업기억에만 머물뿐이다. 당장 오늘 배운 내용을 머릿속에 집어넣는 것도 중요하지만, 들어왔던 지식이 도망가지 않게 붙잡아 두는 것이 더 중요하다. 중요도를 따지자면 3:7정도 ? 복습을 좀 잘해보자. 그러기 위해선 keyword를 그날 그날 잘 정리해 두는 것이 굉장히 중요해보인다. 보완해야할 점 블로그에 내가 배웠고 느꼈던 점들을 포스팅하고 있는데, 포스팅 규칙이 정해져있지 않아서 블로그 가독성도 많이 떨어져 보이고, 원래 내 목적이었던 한달 뒤에도 들춰볼 수 있는 블로그 만들기 가 한달 뒤에 도대체 어디서부터 뭘 봐야하는가 로 바뀔 우려가 있어보인다. 주말을 이용해서 간단하게 포스팅 규칙을 정해보도록 하자.","link":"/2022/12/27/wil-2212-5th/"},{"title":"TIL 221226 transition, animation, responsive","text":"transtion transition을 왜 쓰는가? transition속성을 요소의 ‘전’ 상태에 선언해야하는 이유. transition의 개별 속성과 기본값 animation animation을 왜 쓰는가? animation의 개별 속성과 기본값 animation의 at-rules(@) responsive (media) media 는 언제 쓰이나 ? media의 at-rules(@) media type의 기본값 === all (굳이 명시? 생략하련다) media query max-width와 min-width의 의미 현업에서 반응형을 짜는 flow 요소를 가변적으로 만들면 해결이 되는가 ?","link":"/2022/12/27/til-221226-css/"},{"title":"TIL 221227 CSS Grid","text":"Grid System grid-template-xxx 와 grid-auto-xxx에서 template , auto가 가지는 의미 grid 속성값에서 span이 가지는 의미 Track, Line(=gutter), Cell ,Area fraction =&gt; fr grid-auto-flow CSS 기타 css를 html구조의 순서에 맞게 짜는게 중요한 이유 ‘배치’ 라는 것은 다른 요소와 겹칠 수 있는 가능성이 있다 라는 것 z-index는 기본적으로 자신의 position 값이 static 이외의 다른 값을 가질 때 지정가능. 위의 기본적인 사항 이외에 flex container나 grid container 내부의 자식에 z-index를 설정할 수 있는 등 예외적인 사항이 몇 가지 있는 것으로 보이나, 실제로 이렇게 쓰일지는 의문. 기본값 z-index : auto; 부모 요소를 물려받음. span 태그 안에 div 넣기 ? 불가능 a 태그 안에 div 넣기? 하나까지 가능 … 그 이유 ? 화면에 나중에 그려지는게 먼저 그려진거 위에 그려질 수 밖에.","link":"/2022/12/27/til-221227-css/"},{"title":"CSS BEM 방법론 (조금 더 연습이 필요 ++)","text":"BEM 방법론Block, Element, Modifier 장점 클래스 네임만으로 마크업 구조를 알 수 있다. 클래스 네임 자체에 구조적 의미가 담겨있기 때문에 CSS 속성 지정 시 셀렉팅을 늘어지게 할 필요가 없다. SCSS에서 Nesting 구조를 만들 때 더욱 효과적! Block (독립성) 독립적으로 쓰일 수 있고, 다른 곳에 재사용이 되겠는가? block 끼리는 Nesting해서 쓰지 않음. Element (의존성) Block 내에서만 의미를 가짐. 따로 떼어다 다른 곳에서 사용 X Modifier 다르게 동작하거나, 생긴게 약간 다르거나. 약간의 속성 변화를 관리","link":"/2022/12/30/221230-css-bem/"},{"title":"CSS Selector","text":"CSS Selector에 대해 알아보자.(내용 빈약 주의)Keywords기본 선택자 전체 선택자 (*) tag 선택자 class 선택자 id 선택자 복합 선택자 일치 선택자 : 서로 다른 선택자를 붙여 쓰기 자식(직계) 선택자 : &gt; 하위(후손) 선택자 : 띄어쓰기 인접 형제 선택자 : + ABC + XYZ : ABC의 다음 형제 요소 XYZ 하나를 선택 일반 형제 선택자 : ~ ABC ~ XYZ : ABC의 다음 형제 요소 중 XYZ 모두를 선택 가상 클래스 선택자 : 사용자가 어떤 행동을 했을 때 hover, focus, active … cf) focus가 될 수 있는 요소 : 뭘까~요? 1) focus가 될 수 없는 요소지만 ? 속성을 부여하면 focus가 된다 ! 2) 선택자에 조건을 붙일 때 :first-child, :last-child :nth-child(n) :not() 전체 선택자 *(애스터리스크)와 함께라면 굉장히 유용 ! *:nth-child() *:not() 가상 요소 선택자 :: HTML 구조에 가상 요소를 삽입할 때 HTML 요소를 추가하지 않고 CSS선에서 끝내므로 구조적으로 훨씬 간단해질 수 있는 아주 유용한 아이! ::before , ::after 선택된 HTML 요소의 맨 앞 또는 맨 뒤에 삽입. 가상 요소는 inline 요소. content : “” 필수 속성 선택자 [] [ABC] : 단순 속성을 선택할 때 [ABC=&quot;XYZ&quot;] : [type=&quot;password&quot;] 처럼 프로퍼티가 여러 값을 가질 때 정답 HTML 대화형 콘텐츠 input, a, button, label, select … tabindex 순서값으로 -1이 아닌 값을 넣으면 논리적 흐름을 방해하므로, -1을 권장.","link":"/2022/12/30/221228-css-selector/"},{"title":"CSS width &#x2F; height 속성의 동작.","text":"맨날 헷갈리는 width와 height에 대하여!작동 방식 width와 height 모두 기본값은 auto로 설정되어있다. 그럼 auto가 가지는 의미가 뭘까? 브라우저가 알아서 계산하겠다 이거임. 그럼 브라우저는 뭘 기준으로 계산하는데 ? 해당 요소의 display 속성을 기준으로 계산하는 방식을 다르게 가져감. inline 요소는 애초에 layout을 다루기 위해 태어난 것이 아니라 width, height 값을 content요소의 크기만큼 (이 말은 최대한 쪼금만 차지하겠다 이거.) 가져간다. block 요소의 width는 최대한 넓게(부모의 width가 있다면 그만큼까지), height는 최대한 적게 가져간다. display : flex가 적용된 flex container 도 block과 동일하게 동작(inline-flex 값이 따로 존재함.) 헌데 부모가 flex-container인, 즉 flex item들은 width를 최대한 적게 가져가려함. 왜 ? 수평 정렬을 하려고 flex를 쓰는 거니까. width를 있는대로 다 가져가면 공간이 안나니까 정렬을 할 수가 없겠지. 또한 flex item의 height는 부모의 높이값을 최대한 모두 가져감. (이..건 좀 알아보자) max-width / min-width max-width : 요소가 늘어날 수 있는 한계를 지정 min-width : 요소가 줄어들 수 있는 한계를 지정 flexible box를 다룰 때 flex-grow, flex-shrink와 함께 요긴하게 쓰일 듯. box-sizing 기본값 : content-box 요소의 content 크기로 width와 height를 맞추겠다. border-box : 요소의 content 크기 + padding 값 + border-width 값을 모두 더한 값으로 width와 height를 맞추겠다.","link":"/2022/12/30/221229-css-width/"},{"title":"CSS 보이지 않는 것에 대한 정리.","text":"display : none / visibility : hidden / opacity : 0 / color : transparentdisplay : none 해당 요소를 레이아웃에서 아예 빼버림. 마치 그 요소가 원래 없었던 것처럼 동작하지요. DOM 이벤트 발생 X tab focus X visibility : hidden 레이아웃에 요소는 그대로 존재하나, 다만 우리 눈에 보이지 않게 렌더링 할 뿐이다. (투명 인간느낌 ㅇㅇ) DOM 이벤트 발생 X (오우 이건 좀 헷갈릴 수 있겠는데.. codepen에서 실제로 적용해보니 이벤트 발생하지 않는다.) tab focus X 뒤 요소 클릭 가능. opacity : 0 0(완전 투명), 1(완전 불투명) ,, 즉 불투명도를 조절함. 레이아웃에 존재. DOM 이벤트 발생. tab focus O 뒤 요소 클릭 불가능. color : transparent opacity : 0를 사용하면 요소가 통짜바리로 불투명도가 조절되니까 글자만 냅다 패고 싶을 때 사용하자. 또는 rgba(0,0,0,0.4) 를 사용하기. 정리 레이아웃에서 아예 빼고 싶으면 display : none 레이아웃에 그대로 차지하게 두고, 이외 상호작용에서 빼버리고 싶으면 visibility : none 그냥 다 되는데 안보이게만 하고 싶으면 opacity : 0 안보이게 할 건데 글자만 패고싶으면 color : transparent 또는 rgba(0,0,0,0)","link":"/2022/12/30/221229-css-cantsee/"},{"title":"CSS 배경과 이미지에 관하여","text":"CSS에서 배경과 이미지에 관하여 정리배경 (background)background 속성들 background-color 요소의 배경색을 입힘. 기본값 : transparent background-image : 요소의 배경에 이미지를 렌더링 입히고자 하는 이미지의 경로를 url() 함수의 인자로 넣어준다. 아무런 설정값 없이 이미지를 넣게 되면 요소 안에 이미지 파일이 가지는 실제 크기가 렌더링 됨. background-repeat 이미지가 요소 안에서 반복적으로 출력되게 할 것인지를 지정. 기본값 : repeat , 이미지가 최대한 담길 수 있는 한도 내에서 반복적으로 출력됨. repeat-x / repeat-y / no-repeat의 값으로도 설정할 수 있고, 보통은 no-repeat을 자주 사용하게 될 것 같다. background-position 기본값 : 0% 0% 단위 지정 (축 평행 이동) %지정과 px지정의 작동 방식이 약간 다름. 음수%가 양수px처럼 동작. (결론은 두 단위모두 초기 상태에서 x축, y축으로 얼마만큼 평행이동하여 위치시킬지 지정.) 기준 구역 지정 : top, bottom, left, right, center 정방형 9구역 중 어느 영역을 기준으로 이미지를 위치시킬지 지정(지정된 구역을 기준으로 핀 고정한 게 가장 정확한 듯.) background-size 기본값 : auto (이미지의 실제 크기로 브라우저가 알아서 렌더링) 단위 지정 : 가로 세로 지정해서 넣는데 보통 가로 하나만 넣으면 브라우저가 알아서 원본 비율을 유지하여 세로너비를 지정. cover : 배경이미지가 잘리더라도 요소의 배경에 빈 곳 없이 꽉 차도록 한다. (요소의 긴 너비을 기준으로 비율을 유지) contain : 요소의 배경에 빈 곳이 생기더라도 이미지가 모두 출력되도록 한다. (요소의 짧은 너비을 기준으로 비율을 유지) background-attachment 요소의 배경 이미지 스크롤 특성을 지정한다. 기본값 : scroll (이미지가 html 요소를 따라서 스크롤 됨. 우리가 허구헌날 보는 방식이 요거라 생각하면 됨.) fixed : 이미지가 뷰포트 (화면 렌더링 영역) 에 고정됨. 마치 스크롤 하는데 컨텐츠는 스크롤링되어 딸려올라가거나 내려오는데 배경 이미지는 화면에 그대로 고정되어 있는 느낌. 기타 background-color와 background-image의 쌓임 맥락 : 배경색 위에 이미지가 쌓인다고 보면 됨. 그렇다면 background-image와 &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt;를 언제 어떻게 선택하여 사용할까 ?(배경으로서의 사진을 이용하는 경우가 아니라 단순 사진을 삽입하는 경우에 따져보기) 업데이트 주기 업데이트가 짧다 ? img 태그 쓰기. 이유는 간단하다. 둘의 차이는 html의 src 속성으로 경로를 지정하느냐, css의 속성값으로 url 함수의 인자로 경로를 지정하느냐. 백단에서 css의 속성값에 접근하여 바꿀 방법이 없다고 한다. 그러니 업데이트를 자주할 것 같은 이미지는 img태그의 src 속성을 통하여 지정해주도록 하자. 그럼 업데이트가 자주있는 경우엔 무조건 background-size나 background-position 같은 유용한 속성을 포기해야하느냐? 방법이 있긴하다. 바로 html에서 style 전역속성을 사용하여 인라인 스타일로 background 속성을 주는 것. 이렇게 되면 백단에서 경로값을 가져와서 수정할 수 있다. object-fit, object-position으로 background-size, background-position을 대체할 수 있다.","link":"/2023/01/01/221231-css-background/"},{"title":"패스트캠퍼스 프론트엔드 개발과정 4기 1차 과제 회고","text":"패스트캠퍼스 프론트엔드 개발과정 4기 1차 과제(클론코딩) 회고","link":"/2022/12/31/221230-fastcampus-1st-proj/"},{"title":"TIL 230101 (CSS)","text":"230101 오늘의 학습position position은 배치다. position : absolute 또는 postion : fixed 적용 시 해당 요소는 display : block 이 자동으로 적용됨. 쌓임 맥락 요소에 position 속성이 지정되어 있나 ? (static 제외) 1번 만족, z-index 속성의 값이 클 수록 위에 쌓임. 1,2번 조건이 모두 동일할 시, HTML구조 상 나중의 것이 위에 쌓임. z-index의 기본값은 auto이다. (부모의 것을 상속받음.) flex flex container는 block으로 동작. (display : inline-flex으로 다르게 동작시킬 수 있다.) (flex-direction : row일 경우) flex item들은 기본적으로 width를 콘텐츠 영역만큼(즉, 최소한으로)만 가져감. 정렬은 콘텐츠들과 남는 공간(여백)을 가지고 다룰 수 있기 때문에, 반대로 생각해서 여백없이 width를 최대한으로 가져가버리면 정렬이란걸 할 수 없게 된다. align-items : stretch, align-content : stretch 기본값이 최대한 늘어나는 것이라 height에 따로 지정한 값이 없다면(즉, height : auto) height는 쭉쭉 늘어남.","link":"/2023/01/02/til-230101-css/"},{"title":"데이터 타입이 필요한 이유","text":"데이터 타입이 필요한 이유가 뭘까요Modern Javascript Deep Dive의 내용을 요약했습니다. 값은 메모리에 저장하고 참조할 수 있어야한다. 값을 저장할 경우 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야한다. 다시 말해, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실없이 값을 저장할 수 있는지 알아야 한다. 자바스크립트 엔진은 데이터의 타입에 따라 정해진 크기의 메모리 공간을 확보한다. 값을 참조하는 경우 예를 들어, score라는 변수에 숫자 100이라는 값이 저장되어있는 경우, 식별자 score를 통해 숫자 값 100이 저장되어있는 메모리 공간의 선두 메모리 셀의 주소를 찾아간다. 이때 값을 정상적으로 참조하려면 한번에 읽어들여야할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야한다. 그렇게 하지 못하면 값이 훼손될 가능성이 있다. 자바스크립트 엔진은 score 변수에 저장된 값을 숫자 타입으로 인식하고, 숫자 타입은 8바이트의 고정단위로 저장되므로 8바이트 단위로 읽어들인다. 메모리에서 읽어들인 값의 해석 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만, 문자열로 해석하면 ‘A’이다. 정리 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어들인 2진수를 어떻게 해석해야할지 결정하기 위해 ECMAScript 사양에서는 문자열과 숫자타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지 않다. 따라서 문자열과 숫자 타입 외의 데이터 타입은 확보되는 메모리 공간의 크기가 자바스크립트 엔진 제조사의 구현에 따라 다를 수 있다.","link":"/2023/01/02/230102-js-data-type/"},{"title":"Javascript NaN 에 관하여","text":"NaN (Not A Number) 프로그래머스 입문 숨어있는 숫자의 덧셈(1) 문제를 풀며 들었던 의문과 함께 정리해본다. 숨어있는 숫자의 덧셈(1) 문제 설명 문제 설명 문자열 my_string이 매개변수로 주어집니다. my_string안의 모든 자연수들의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 my_string은 소문자, 대문자 그리고 한자리 자연수로만 구성되어있습니다. 입출력 예 my_string result “aAb1B2cC34oOp” 10 “1a2b3c4d123” 16 입출력 예 설명 입출력 예 #1 : “aAb1B2cC34oOp”안의 한자리 자연수는 1, 2, 3, 4 입니다. 따라서 1 + 2 + 3 + 4 = 10 을 return합니다. 입출력 예 #2 : “1a2b3c4d123Z”안의 한자리 자연수는 1, 2, 3, 4, 1, 2, 3 입니다. 따라서 1 + 2 + 3 + 4 + 1 + 2 + 3 = 16 을 return합니다. 유의사항 연속된 숫자도 각각 한 자리 숫자로 취급합니다. 최종 풀이 12345678910function solution(my_string) { const my_string_arr = Array.from(my_string); let answer = 0; my_string_arr.forEach((element) =&gt; { if (!isNaN(element)) { answer += Number(element); } }); return answer;} NaN이란 ? NaN은 Not A Number 즉, 숫자가 아니라는 의미의 숫자 타입의 데이터이며, 전역 객체의 속성이다. (실제로 브라우저환경이나, Node.js환경에서 전역 객체를 찍어보면, 내부에 NaN이 들어있다.) NaN을 반환하는 연산 다섯가지 숫자로서 읽을 수 없음 (parseInt(“어쩌구”), Number(undefined)) 결과가 허수인 수학 계산식 (Math.sqrt(-1)) 피연산자가 NaN (7 ** NaN) 정의할 수 없는 계산식 (0 * Infinity) 문자열을 포함하면서 덧셈이 아닌 계산식 (“가” / 3) NaN 판별법 NaN의 판별 Number.isNaN() 또는 isNaN() 을 이용. isNaN()과 Number.isNaN()의 차이를 주의. isNaN은 현재 값이 NaN이거나, 숫자로 변환했을 때 NaN이 되면 참을 반환하지만, Number.isNaN은 현재 값이 NaN이어야만 참을 반환. 자기 자신과 같지 않음을 이용12345function valueIsNaN(v) { return v !== v;}valueIsNaN(1); // falsevalueIsNaN(NaN); // true (주의) 일부 배열 메서드는 NaN을 찾을 수 없다.1234let arr = [2, 4, NaN, 12];arr.indexOf(NaN); // -1 (false)arr.includes(NaN); // truearr.findIndex((n) =&gt; Number.isNaN(n)); // 2","link":"/2023/01/02/230102-js-NaN/"},{"title":"전역 변수의 문제점과 억제 방안","text":"","link":"/2023/01/02/230102-js-global-variable/"},{"title":"TIL 230102 javascript","text":"2차 과제 (영화 검색 api 만들기) preview과제 상세 내용 Client의 요청과 Server 측에서의 인증, apikey, feat.queryString 프론트단에서 만들어진 코드를 숨기는 것은 불가능함. Serverless function을 이용한 data 은닉? how ? keydown 이벤트와 isComposing 프로퍼티 한글 사용 시 발생되는 문제(이벤트 두번 호출)를 방지.","link":"/2023/01/02/til-230102-js/"}],"tags":[{"name":"error","slug":"error","link":"/tags/error/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"etc","slug":"etc","link":"/tags/etc/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"},{"name":"국비지원교육","slug":"국비지원교육","link":"/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EA%B5%90%EC%9C%A1/"},{"name":"메가바이트스쿨","slug":"메가바이트스쿨","link":"/tags/%EB%A9%94%EA%B0%80%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%8A%A4%EC%BF%A8/"},{"name":"MegabyteSchool","slug":"MegabyteSchool","link":"/tags/MegabyteSchool/"},{"name":"개발자취업부트캠프","slug":"개발자취업부트캠프","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/"},{"name":"내일배움카드","slug":"내일배움카드","link":"/tags/%EB%82%B4%EC%9D%BC%EB%B0%B0%EC%9B%80%EC%B9%B4%EB%93%9C/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"clone","slug":"clone","link":"/tags/clone/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"}],"categories":[{"name":"html&#x2F;css","slug":"html-css","link":"/categories/html-css/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"error","slug":"error","link":"/categories/error/"},{"name":"Weekly Recap","slug":"Weekly-Recap","link":"/categories/Weekly-Recap/"},{"name":"wil","slug":"wil","link":"/categories/wil/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"algorithm","slug":"javascript/algorithm","link":"/categories/javascript/algorithm/"}],"pages":[]}