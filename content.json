{"posts":[{"title":"(Error) git init으로 프로젝트 시작하기 vs git clone으로 프로젝트 시작하기","text":"상황 설명 로컬에서 hexo blog framework로 blog 구축 project를 시작함. github에서 github blog 생성하기 위해 repo 생성. 위의 원격 repo에 hexo-deployer-git plugin을 사용하여 deploy함. hexo project에서 static file들은 public폴더에서 관리하므로, git으로 버전 관리를 하기 위해 public 폴더에 git init 시전. 에러 메세지들 123$ git push origin mainerror: src refspec main does not match anyerror: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git' remote에는 master branch가 없기 때문에 출력된 에러 메세지 123456789$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (fetch first)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. remote에 있는 것들이 당연하게 내 local에도 있어야 하는데, 없으니까 일단 pull로 땡겨와라. 라는 메세지 12345678910$ git pull origin mainremote: Enumerating objects: 46, done.remote: Counting objects: 100% (46/46), done.remote: Compressing objects: 100% (27/27), done.remote: Total 46 (delta 9), reused 46 (delta 9), pack-reused 0Unpacking objects: 100% (46/46), 129.91 KiB | 601.00 KiB/s, done.From https://github.com/bongsee/bongsee.github.io * branch main -&gt; FETCH_HEAD * [new branch] main -&gt; origin/mainfatal: refusing to merge unrelated histories 관련 없는 기록 병합 거부 remote의 commit history와 local의 commit history가 관련성이 없기 때문에 merge하는데 실패하는 것 기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit지점이 존재해야 한다.그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit이 없기때문에 pull 명령어를 사용할 수 없는 것이다. 12345678$ git push origin mainTo https://github.com/bongsee/bongsee.github.io.git ! [rejected] main -&gt; main (non-fast-forward)error: failed to push some refs to 'https://github.com/bongsee/bongsee.github.io.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 힌트 : 현재 지점의 끝이 원격 지점 뒤에 있기 때문에 업데이트가 거부되었습니다. 다시 푸시하기 전에 원격 변경 사항을 통합하십시오. rejected : push가 거부되었다. master -&gt; master : 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 했는데 non-fast-forward : 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다. 라는 의미이다. 그럼 git push는 내부적으로 어떻게 할지말지를 판단하나 ? push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다.그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 정리 애초에 접근부터가 잘못됐다. (git clone)원격 repo에서 프로젝트를 시작했으면, 해당 repo를 clone해와서 repo와 local을 동기화시킨 이후에 작업을 해야하는 것이고, (git init)local에서 프로젝트를 시작했으면, remote에 대한 설정과 upstream 링크를 걸어주는 등의 작업을 직접해야하는 것이다. 결론은 어쨌든 연결되는 공통된 커밋 포인트가 없다는 것. 아~ 최우영 강사님,, 이제야 깨닫습니다. 왜 remote에서 시작해서 clone하는게 편한지요… Refs https://jobc.tistory.com/177","link":"/2022/12/19/221219_error_git/"},{"title":"Data Format에 대해","text":"Data Format (22.12.17)Focus 데이터 포맷이 왜 필요할까 ? JSON YAML 데이터 직렬화/역직렬화 1. 데이터 포맷이 왜 필요할까 ? 혼자 개발하거나, 내부적으로 데이터를 사용할 땐 내부의 규칙을 문서화하고 참고하면 그만이지만, 문제는 타인 또는 타 시스템과 연동을 해야할 때다. 데이터를 주고 받을 때 마다 각자 정해진 규칙을 문서로 주고 받는 것도 비효율적이고, 하나의 통일된 규칙이 없을 때 생기는 불필요한 문서들이 많아지기 마련임. 이렇게 상호가 데이터를 효율적으로 다루고자 통일된 규칙을 가지는 ‘format’이 등장하게 된다. XML, JSON, YAML 등이 있다. 2. JSON JSON 데이터 포맷 예시1234567891011121314151617181920212223242526272829303132{ &quot;name&quot;: &quot;Rust&quot;, &quot;on&quot;: { &quot;push&quot;: { &quot;branches&quot;: [&quot;master&quot;] }, &quot;pull_request&quot;: { &quot;branches&quot;: [&quot;master&quot;] } }, &quot;env&quot;: { &quot;CARGO_TERM_COLOR&quot;: &quot;always&quot; }, &quot;jobs&quot;: { &quot;build&quot;: { &quot;runs-on&quot;: &quot;ubuntu-latest&quot;, &quot;steps&quot;: [ { &quot;uses&quot;: &quot;actions/checkout@v2&quot; }, { &quot;name&quot;: &quot;Build&quot;, &quot;run&quot;: &quot;cargo build --verbose&quot; }, { &quot;name&quot;: &quot;Run tests&quot;, &quot;run&quot;: &quot;cargo test --verbose&quot; } ] } }} 데이터 직렬화에 유리하여 일반적으로 데이터 전송, AJAX 통신 등 API 통신에 주로 사용됨. XML은 헤더와 태그 등으로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 있었던 데 반해 JSON은 나은 가독성, 효율성을 가진다. 주석을 지원하지 않는다. 데이터 타입을 강제하려면 JSON 스키마로 보완해야한다. 3. YAML YAML 데이터 포맷 예시123456789101112131415161718#!syntax yamlname: Ruston: push: branches: [master] pull_request: branches: [master]env: CARGO_TERM_COLOR: alwaysjobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Build run: cargo build --verbose - name: Run tests run: cargo test --verbose​ 주로 수정이 잦은 설정(conf) 파일에 사용됨. XML, JSON 보다 직관적이라 가독성이 좋다. 주석이 가능하다. 데이터 타입을 명시해줄 수 있다. 데이터 직렬화가 불편하다. 4. 데이터 직렬화/역직렬화 : (보완, 수정 요 - 운영체제) 직렬화(Serialization)란, 참조 타입의 데이터를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형태로 변환하는 작업임. 역직렬화(Deserialization)란, 디스크에 저장된 데이터를 읽거나, 네트워크를 통해 전송받은 데이터를 메모리에 저장하기 위한 형태로 변환하는 작업임. 메모리에서 데이터가 가지는 구조는 2가지다. 값(Value) 형식 데이터 참조(Reference) 형식 데이터 : 객체 타입이 여기에 해당. 이 두가지 데이터 중 디스크에 저장하거나 네트워크 통신을 할 수 있는 데이터는 값(Value) 형식의 데이터다. 직렬화를 통해 참조 형태의 데이터를 값 형태로 변환.","link":"/2022/12/19/221218_data_format/"},{"title":"Mark down 문법 정리(+ 업데이트 중)","text":"* 구분선--- * 텍스트 강조**강조될 텍스트** 강조될 텍스트 / 일반 텍스트 * 이미지 삽입![이미지 이름](이미지 주소) * 줄 바꿈엔터 두번 * 줄 여러번 바꾸기&lt;br&gt;","link":"/2022/12/18/221218_markdown/"}],"tags":[{"name":"error","slug":"error","link":"/tags/error/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"etc","slug":"etc","link":"/tags/etc/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"}],"categories":[],"pages":[]}