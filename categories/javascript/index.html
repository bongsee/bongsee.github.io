<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta name="description" content="배운게 있다면 나만의 언어로 정리하라"><meta name="keywords" content="HTML, CSS, Javascript, frontend, git, TIL"><meta name="author" content="BS K"><title>카테고리: javascript - Bonglog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Bonglog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Bonglog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Bonglog"><meta property="og:url" content="https://bongsee.github.io/"><meta property="og:site_name" content="Bonglog"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://bongsee.github.io/img/og_image.png"><meta property="article:author" content="BS K"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://bongsee.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://bongsee.github.io"},"headline":"기록의 공간","image":["https://bongsee.github.io/img/og_image.png"],"author":{"@type":"Person","name":"BS K"},"publisher":{"@type":"Organization","name":"Bonglog","logo":{"@type":"ImageObject"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Bonglog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">javascript</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-28T09:10:07.617Z" title="2023. 1. 28. 오후 6:10:07">2023-01-28</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-29T09:41:08.595Z" title="2023. 1. 29. 오후 6:41:08">2023-01-29</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">18분안에 읽기 (약 2751 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/28/230128-spa-routing/">SPA와 Routing</a></h1><div class="content"><h1 id="SPA와-Routing"><a href="#SPA와-Routing" class="headerlink" title="SPA와 Routing"></a>SPA와 Routing</h1><ul>
<li>본 Repo는 이웅모님의 웹사이트 poiemaweb의 포스팅 <a target="_blank" rel="noopener" href="https://poiemaweb.com/js-spa">SPA &amp; Routing</a>에 100% 의존하고 있습니다.</li>
<li>김상헌 멘토님의 추천으로 해당 포스팅을 접했고, 포스팅에 소개되어있는 소스코드가 인상 깊어서 백지부터 소스코드를 짜보며 SPA와 Routing에 대한 이해를 높히고자 함에 그 목적이 있습니다.</li>
<li><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-spa">SPA &amp; Routing</a> 포스팅의 내용을 키워드 중심으로 나열하여 다시 봤을 때 효과적으로 상기시킬 수 있도록 합니다.</li>
</ul>
<h2 id="SPA란"><a href="#SPA란" class="headerlink" title="SPA란 ?"></a>SPA란 ?</h2><h3 id="기존-link-tag를-통한-화면-전환-방식의-단점"><a href="#기존-link-tag를-통한-화면-전환-방식의-단점" class="headerlink" title="기존 link tag를 통한 화면 전환 방식의 단점"></a>기존 link tag를 통한 화면 전환 방식의 단점</h3><ul>
<li>새로운 페이지 요청 시마다 정적 리소스 다운로드</li>
<li>전체 페이지를 리렌더링 : 새로고침 현상</li>
</ul>
<h3 id="SPA의-장점"><a href="#SPA의-장점" class="headerlink" title="SPA의 장점"></a>SPA의 장점</h3><ul>
<li><p>ajax를 통한 트래픽 감소</p>
<ul>
<li>웹 애플리케이션에 필요한 모든 정적 리소스를 최초 접근 시 단 한번 다운로드</li>
<li>이후 ajax 통신을 통해 변경된 부분만 갱신</li>
</ul>
</li>
<li><p>사용자 경험(UX) 향상</p>
<ul>
<li>새로고침 현상 제거</li>
</ul>
</li>
</ul>
<h3 id="SPA의-단점-trade-off"><a href="#SPA의-단점-trade-off" class="headerlink" title="SPA의 단점(trade-off)"></a>SPA의 단점(trade-off)</h3><ul>
<li><p>초기 구동 속도가 느리다.</p>
</li>
<li><p>SEO(검색 엔진 최적화) 이슈</p>
<ul>
<li>SPA방식에서 사용되는 CSR(Client Side Rendering)</li>
<li>CSR방식은 일반적으로 데이터 패치 요청을 통해 서버로부터 데이터를 응답받아 뷰를 동적으로 생성.</li>
<li>이 때 브라우저 주소창의 URL이 변경되지 않고 이는 곧, 브라우저의 History를 관리할 수 없음을 의미한다.</li>
</ul>
</li>
</ul>
<h2 id="Routing-이란"><a href="#Routing-이란" class="headerlink" title="Routing 이란 ?"></a>Routing 이란 ?</h2><ul>
<li><p>Routing</p>
<ul>
<li>라우팅이란, 출발지에서 목적지까지의 경로를 설정하는 기능</li>
<li>애플리케이션에서의 라우팅은 User가 Task를 수행하기 위해 어떤 화면(View)에서 다른 화면으로 화면을 전환하는 내비게이션 관리를 위한 기능을 의미.</li>
<li>일반적으로 라우팅은 사용자가 요청한 URL 또는 이벤트를 해석하고 새로운 페이지로 전환하기 위해 필요한 데이터를 서버에 요청하고 페이지를 전환하는 일련의 행위를 말함.</li>
</ul>
</li>
<li><p>브라우저에서 화면을 전환하는 경우</p>
<ul>
<li>브라우저의 주소창에 URL을 입력</li>
<li>웹페이지의 링크(a 태그)를 클릭</li>
<li>브라우저의 뒤로가기 또는 앞으로가기 버튼을 클릭(사용자 방문기록 - history 기반)<ul>
<li>history 관리를 위해서는 각 페이지는 구별할 수 있는 고유한 URL을 소유해야한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SPA와-Rounting"><a href="#SPA와-Rounting" class="headerlink" title="SPA와 Rounting"></a>SPA와 Rounting</h2><ul>
<li><p>살펴볼 케이스는 총 4가지이다.</p>
<ul>
<li>전통적 링크 방식 (link)</li>
<li>ajax</li>
<li>ajax + hash</li>
<li>ajax + pushState(pjax)</li>
</ul>
</li>
<li><p>각각의 소스코드를 해석해보고, 각 방식이 가지는 trade-off를 알아보자.</p>
</li>
</ul>
<h2 id="Routing-방식-4가지"><a href="#Routing-방식-4가지" class="headerlink" title="Routing 방식 4가지"></a>Routing 방식 4가지</h2><h3 id="1-link"><a href="#1-link" class="headerlink" title="1. link"></a>1. link</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SPA-Router - Link<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/service.html&quot;</span>&gt;</span>Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about.html&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is main page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>a tag의 href 속성값인 리소스 경로가 <code>URL의 path에 추가</code>되고 해당 리소스를 <code>서버에 요청</code>한다.</li>
<li>서버는 리소스를 클라이언트에 응답(<code>서버 사이드 렌더링(SSR)</code>).</li>
<li>브라우저는 서버가 응답한 html을 렌더링하게 되므로 <code>새로고침</code>이 발생.</li>
</ul>
<img src="https://poiemaweb.com/img/traditional-webpage-lifecycle.png" width="400" />

<ul>
<li>각 페이지마다 고유의 URL이 존재하므로 <code>history 관리 및 SEO 대응에 아무런 문제가 없다</code>.</li>
<li>하지만 요청마다 <code>중복된 리소스를 응답</code>받아야 하며 전체 페이지를 다시 렌더링하는 과정에서 <code>새로고침이 발생</code></li>
</ul>
<h3 id="2-ajax"><a href="#2-ajax" class="headerlink" title="2. ajax"></a>2. ajax</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SPA-Router - ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;navigation&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- a href 속성값으로 서버 측에서 미리 정의한(약속된) endpoint를 사용한다. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/service&quot;</span>&gt;</span>Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ajax 방식은 내비게이션 <code>클릭 이벤트를 캐치</code>하고 사전에 <code>서버로의 요청을 방지</code>한다.</li>
<li>후에 href 속성값으로 명시된 path를 추출하여 <code>ajax 요청</code>을 실시한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Home</span>, <span class="title class_">Service</span>, <span class="title class_">About</span>, <span class="title class_">NotFound</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./components.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> navigationEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;navigation&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> rootEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/service&quot;</span>, <span class="attr">component</span>: <span class="title class_">Service</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// path에 맞는 컴포넌트 반환</span></span><br><span class="line">    <span class="keyword">const</span> component =</span><br><span class="line">      routes.<span class="title function_">find</span>(<span class="function">(<span class="params">route</span>) =&gt;</span> route.<span class="property">path</span> === path)?.<span class="property">component</span> ?? <span class="title class_">NotFound</span>;</span><br><span class="line">    <span class="comment">// 만들어진 컴포넌트를 html root요소에 삽입</span></span><br><span class="line">    rootEl.<span class="title function_">replaceChildren</span>(<span class="keyword">await</span> <span class="title function_">component</span>());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax 요청은 주소창의 url을 변경시키지 않으므로 history 관리가 되지 않는다.</span></span><br><span class="line">navigationEl.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&quot;#navigation &gt; li &gt; a&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> path = event.<span class="property">target</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">  <span class="title function_">render</span>(path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주소창의 url이 변경되지 않기 때문에 새로고침 시 현재 렌더링된 페이지가 아닌 루트 페이지가 요청된다.</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> <span class="title function_">render</span>(<span class="string">&quot;/&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createElement</span> = (<span class="params">domString</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tplEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;template&quot;</span>);</span><br><span class="line">  tplEl.<span class="property">innerHTML</span> = domString;</span><br><span class="line">  <span class="keyword">return</span> tplEl.<span class="property">content</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 컴포넌트 반환 함수</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Home</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = <span class="keyword">await</span> <span class="title function_">fetchData</span>(<span class="string">&quot;/api/home&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">`&lt;h1&gt;<span class="subst">$&#123;title&#125;</span>&lt;/h1&gt;&lt;p&gt;<span class="subst">$&#123;content&#125;</span>&lt;/p&gt;`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Service</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = <span class="keyword">await</span> <span class="title function_">fetchData</span>(<span class="string">&quot;/api/service&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">`&lt;h1&gt;<span class="subst">$&#123;title&#125;</span>&lt;/h1&gt;&lt;p&gt;<span class="subst">$&#123;content&#125;</span>&lt;/p&gt;`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">About</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = <span class="keyword">await</span> <span class="title function_">fetchData</span>(<span class="string">&quot;/api/about&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">`&lt;h1&gt;<span class="subst">$&#123;title&#125;</span>&lt;/h1&gt;&lt;p&gt;<span class="subst">$&#123;content&#125;</span>&lt;/p&gt;`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">NotFound</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; <span class="title function_">createElement</span>(<span class="string">`&lt;h1&gt;404 Not Found&lt;/h1&gt;`</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>ajax 요청은 주소창의 <code>URL을 변경시키지 않는다</code>.</li>
<li>브라우저의 뒤로가기, 앞으로가기 등의 <code>history 관리</code>가 동작하지 않음을 의미. 따라서 history.back(), history.go(n) 등도 동작하지 않는다.</li>
<li>주소창의 URL이 변경되지 않기 때문에 새로고침을 해도 <code>언제나 첫 페이지</code>가 다시 로딩된다.</li>
<li>동일한 하나의 URL로 동작하는 ajax 방식은 <code>SEO 이슈</code>에서도 자유로울 수 없다.</li>
</ul>
<h3 id="3-ajax-hash"><a href="#3-ajax-hash" class="headerlink" title="3. ajax + hash"></a>3. ajax + hash</h3><ul>
<li>ajax 방식은 불필요한 리소스 중복 요청을 방지할 수 있고 새로고침이 없는 사용자 경험을 구현할 수 있다는 장점이 있지만 <code>history 관리가 되지 않는 단점</code>이 있다.</li>
<li>이를 보완한 방법이 Hash 방식이다.</li>
<li>Hash 방식은 <code>URI의 fragment identifier(#service)</code>의 고유 기능인 <code>앵커(anchor)</code>를 사용한다.</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SPA-Router - Hash<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;navigation&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#service&quot;</span>&gt;</span>Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>URL이 동일한 상태에서 hash만 변경</code>되면 브라우저는 <code>서버에 어떠한 요청도 하지 않는다</code>. 즉, 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않는다.</li>
<li>hash는 요청을 위한 것이 아니라 fragment identifier(#service)의 고유 기능인 앵커(anchor)로 <code>웹페이지 내부에서 이동을 위한 것</code>이기 때문이다.</li>
<li>hash 방식은 페이지마다 <code>고유의 논리적 URL이 존재</code>하므로 <code>history 관리에 아무런 문제가 없다</code>.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Home</span>, <span class="title class_">Service</span>, <span class="title class_">About</span>, <span class="title class_">NotFound</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./components.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;service&quot;</span>, <span class="attr">component</span>: <span class="title class_">Service</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// url의 hash 정보 추출</span></span><br><span class="line">    <span class="keyword">const</span> hash = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">replace</span>(<span class="string">&quot;#&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> component =</span><br><span class="line">      routes.<span class="title function_">find</span>(<span class="function">(<span class="params">route</span>) =&gt;</span> route.<span class="property">path</span> === hash)?.<span class="property">component</span> ?? <span class="title class_">NotFound</span>;</span><br><span class="line">    rootEl.<span class="title function_">replaceChildren</span>(<span class="keyword">await</span> <span class="title function_">component</span>());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url의 hash가 변경하면 발생하는 이벤트인 `hashchange` 이벤트를 사용하여 hash의 변경을 감지하여 필요한 ajax 요청을 수행.</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, render);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 함수는 url의 hash를 취득해 새로고침 직전에 렌더링되었던 페이지를 다시 렌더링.</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, render);</span><br></pre></td></tr></table></figure>

<ul>
<li>또 다른 문제는 <code>SEO 이슈</code>이다. 웹 크롤러는 검색 엔진이 웹사이트의 콘텐츠를 수집하기 위해 HTTP와 URL 스펙(RFC-2396같은)을 따른다. 이러한 크롤러는 JavaScript를 실행시키지 않기 때문에 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다. 구글은 해시뱅을 일반적인 URL로 변경시켜 이 문제를 해결한 것으로 알려져 있지만 다른 검색 엔진은 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없을 수도 있다.</li>
</ul>
<h3 id="4-ajax-pushState-pjax"><a href="#4-ajax-pushState-pjax" class="headerlink" title="4. ajax + pushState (pjax)"></a>4. ajax + pushState (pjax)</h3><ul>
<li>hash 방식의 가장 큰 단점은 <code>SEO 이슈</code>이다.</li>
<li>이를 보완한 방법이 HTML5의 <code>History API인 pushState</code>와 <code>popstate 이벤트</code>를 사용한 <code>pjax(pushState + ajax)</code> 방식이다.</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SPA-Router - Pjax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;navigation&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/service&quot;</span>&gt;</span>Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>내비게이션 <code>클릭 이벤트를 캐치</code>하고 preventDefault 메서드를 사용해 <code>서버로의 요청을 방지</code>한다. 이후, href 속성값 path을 사용하여 ajax 요청을 하는 방식.</li>
<li><code>ajax 요청은 브라우저 주소창의 URL을 변경시키지 않아 history 관리가 불가능</code>하다. 이때 사용하는 것이 <code>pushState 메서드</code>이다.</li>
<li>pushState 메서드는 <code>주소창의 URL을 변경</code>하고 <code>URL을 history entry로 추가</code>하지만 <code>서버로 HTTP 요청을 하지는 않는다</code>.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Home</span>, <span class="title class_">Service</span>, <span class="title class_">About</span>, <span class="title class_">NotFound</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./components.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> navigationEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;navigation&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> rootEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/service&quot;</span>, <span class="attr">component</span>: <span class="title class_">Service</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = <span class="keyword">async</span> (<span class="params">path</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 새로고침 혹은 앞으로 가기/ 뒤로가기 시 path값을 처리하기 위해 _path 변수를 통해 상태 관리를 한다.</span></span><br><span class="line">  <span class="keyword">const</span> _path = path ?? <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> component =</span><br><span class="line">      routes.<span class="title function_">find</span>(<span class="function">(<span class="params">route</span>) =&gt;</span> route.<span class="property">path</span> === _path)?.<span class="property">component</span> || <span class="title class_">NotFound</span>;</span><br><span class="line">    rootEl.<span class="title function_">replaceChildren</span>(<span class="keyword">await</span> <span class="title function_">component</span>());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">navigationEl.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&quot;#navigation &gt; li &gt; a&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">const</span> path = event.<span class="property">target</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이동할 페이지가 현재 페이지와 같다면 함수 종료</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> === path) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br><span class="line">  <span class="title function_">render</span>(path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 웹페이지가 처음 로딩되면 window.location.pathname를 확인해 페이지를 이동시킨다.</span></span><br><span class="line"><span class="comment"> * 새로고침을 클릭하면 현 페이지(예를 들어 localhost:5004/service)가 서버에 요청된다.</span></span><br><span class="line"><span class="comment"> * 이에 응답하는 처리는 서버에서 구현해야 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>history.pushState 메서드는 주소창의 url을 변경하지만 HTTP 요청을 서버로 전송하지 않는다.</p>
</li>
<li><p>페이지마다 고유의 URL이 존재하므로 <code>history 관리가 가능</code>하다.</p>
</li>
<li><p>hash를 사용하지 않으므로 <code>SEO에도 문제가 없다</code>.</p>
</li>
<li><p>주의할 점은, 브라우저의 <code>새로고침</code> 버튼을 클릭하면 pjax 방식은 pushState로 바뀐 주소창의 URL 경로로 서버에 요청을 보내기 때문에 이에 대한 처리가 필요하다.</p>
</li>
<li><p>즉, pjax 방식은 서버 렌더링 방식과 ajax 방식이 혼재되어 있는 방식으로 <code>서버의 지원이 필요</code>하다. 이에 대한 서버 구현은 다음과 같다.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">5004</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;public&quot;</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/api/:page&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; page &#125; = req.<span class="property">params</span>;</span><br><span class="line">  res.<span class="title function_">sendFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">`data/<span class="subst">$&#123;page&#125;</span>.json`</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 페이지 새로고침을 위한 처리</span></span><br><span class="line"><span class="comment">// 브라우저 새로고침 시 서버는 index.html을 전달하고 클라이언트는 window.location.pathname를 참조해 다시 라우팅한다.</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">sendFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;public/index.html&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Listening on https:/localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><table>
<thead>
<tr>
<th>구분</th>
<th>History 관리</th>
<th>SEO 대응</th>
<th>사용자 경험</th>
<th>서버 렌더링</th>
<th>구현 난이도</th>
<th>IE 대응</th>
</tr>
</thead>
<tbody><tr>
<td>link 방식</td>
<td>◯</td>
<td>◯</td>
<td>✗</td>
<td>◯</td>
<td>간단</td>
<td></td>
</tr>
<tr>
<td>ajax 방식</td>
<td>✗</td>
<td>✗</td>
<td>◯</td>
<td>✗</td>
<td>보통</td>
<td>7 이상</td>
</tr>
<tr>
<td>ajax + hash 방식</td>
<td>◯</td>
<td>✗</td>
<td>◯</td>
<td>✗</td>
<td>보통</td>
<td>8 이상</td>
</tr>
<tr>
<td>pjax 방식</td>
<td>◯</td>
<td>◯</td>
<td>◯</td>
<td>△</td>
<td>복잡</td>
<td>10 이상</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-15T08:40:42.423Z" title="2023. 1. 15. 오후 5:40:42">2023-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-15T09:04:32.508Z" title="2023. 1. 15. 오후 6:04:32">2023-01-15</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">6분안에 읽기 (약 901 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/15/230114-js-error%EC%B2%98%EB%A6%AC/">에러 처리</a></h1><div class="content"><h1 id="에러-처리"><a href="#에러-처리" class="headerlink" title="에러 처리"></a>에러 처리</h1><ul>
<li>영화 검색 api 토이 프로젝트를 진행하면서 에러 처리의 필요성을 느끼고 관련된 내용을 정리해보고자 한다.</li>
</ul>
<h2 id="에러-처리의-필요성"><a href="#에러-처리의-필요성" class="headerlink" title="에러 처리의 필요성"></a>에러 처리의 필요성</h2><ul>
<li><p>에러가 발생하지 않는 코드를 작성하는 것은 정말 안타깝지만 불가능하다.</p>
</li>
<li><p>에러가 발생하면 프로그램은 강제 종료된다.</p>
</li>
<li><p>그러니 에러 처리는 진짜 중요하다..</p>
</li>
<li><p>기본적으로 에러를 처리하는 방법은 두 가지있다.</p>
<ol>
<li>예외적인 상황이 발생하면 반환하는 값(예를 들어, Array.prototype.indexOf() 메서드가 반환하는 <code>-1</code> 이나, querySelector 메서드가 찾는 요소가 없을 때 반환하는 <code>null</code>)을 if 조건문이나, 단축 평가 또는 옵셔널 체이닝 연산자를 통해 확인해서 처리하는 방법</li>
<li>에러 처리 코드를 미리 등록하고 에러가 발생하면 에러 처리 코드로 점프하도록 하는 방법</li>
</ol>
</li>
<li><p>여기서 다루는 에러 처리에 관한 이야기는 2번의 경우가 되겠다.</p>
</li>
</ul>
<h2 id="try-catch-finally-문"><a href="#try-catch-finally-문" class="headerlink" title="try ~ catch ~ finally 문"></a>try ~ catch ~ finally 문</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 에러 발생의 여지가 있는 코드</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// try문 내에서 에러가 발생하면 실행될 코드</span></span><br><span class="line">  <span class="comment">// err에는 try문에서 발생한 에러 객체가 담긴다.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 에러 발생과 상관없이 반드시 한 번 실행될 코드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Error-객체"><a href="#Error-객체" class="headerlink" title="Error 객체"></a>Error 객체</h2><ul>
<li>Error 생성자 함수는 에러 객체를 생성한다.</li>
<li>Error 생성자 함수가 생성한 에러 객체는 message 프로퍼티와 stack 프로퍼티를 갖는다.<ul>
<li>message 프로퍼티의 값은 Error 생성자 함수에 인수로 전달한 에러 메세지이다.</li>
<li>stack 프로퍼티의 값은 에러를 발생시킨 콜 스택의 호출 정보를 나타내는 문자열이다. (디버깅 목적)</li>
</ul>
</li>
<li>자바스크립트는 Error 생성자 함수를 포함해 7가지 Error 객체를 생성할 수 있는 생성자 함수를 제공한다.<ul>
<li>Error, SyntaxError, ReferenceError, TypeError, RangeError, URIError, EvalError</li>
</ul>
</li>
</ul>
<h2 id="throw-문"><a href="#throw-문" class="headerlink" title="throw 문"></a>throw 문</h2><ul>
<li>Error 생성자 함수로 에러를 생성한다고 에러가 발생되는 것은 아니다. 에러의 생성과 에러의 발생은 다르다.</li>
<li>에러를 발생시키려면 에러 객체를 <code>던져야</code> 한다. <code>throw 표현식;</code></li>
<li>에러를 던지면 catch문의 에러 변수가 생성되고 던져진 에러 객체가 할당된다. 그리고 catch문이 동작하기 시작한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;에러 발생&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Error: 에러 발생</span></span><br><span class="line"><span class="comment">//  at &lt;anonymous&gt;:2:11</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="에러의-전파"><a href="#에러의-전파" class="headerlink" title="에러의 전파"></a>에러의 전파</h2><ul>
<li><code>throw된 에러를 캐치하지 않으면</code> 호출자 방향으로 전파된다.</li>
<li>에러는 호출자 방향으로 전파된다. 즉, 콜 스택의 아래 방향으로 전파된다.</li>
<li>이 과정에서 throw된 에러를 캐치하여 적절히 대응하면 프로그램을 강제 종료시키지 않고 코드의 실행 흐름을 복구시킬 수 있다.</li>
<li>throw된 에러를 어디에서도 캐치하지 않으면 프로그램은 종료된다.</li>
<li>주의할 것은 비동기 함수인 setTimeout이나 프로미스 후속 처리 메서드의 콜백함수는 호출자가 없다는 것이다.<ul>
<li>콜백함수는 이벤트 루프에 의해 콜 스택이 비어지는 순간에 push되므로 콜백 함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재하게 된다.</li>
<li>이는 에러를 전파할 호출자가 없다는 것을 의미한다.</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-12T16:08:52.581Z" title="2023. 1. 13. 오전 1:08:52">2023-01-13</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-18T06:01:40.761Z" title="2023. 1. 18. 오후 3:01:40">2023-01-18</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">11분안에 읽기 (약 1702 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/13/230113-js-promise/">비동기 pattern (Callback, Promise Async/Await)</a></h1><div class="content"><h2 id="Callback-Pattern"><a href="#Callback-Pattern" class="headerlink" title="Callback Pattern"></a>Callback Pattern</h2><ol>
<li><p>비동기 처리 결과의 후속처리를 위한 노력 - <code>Callback Function</code></p>
<ul>
<li>비동기 처리 결과를 외부로 반환하거나, 상위 스코프의 변수에 할당해도 기대한대로 동작하지 않는다.</li>
<li>비동기 함수는 비동기 처리를 <code>기다리지 않고 즉시 종료</code>되기 때문.</li>
<li>비동기 처리 결과를 위한 후속처리는 비동기 함수 내부에서 수행해야한다.</li>
<li>따라서 비동기 처리 결과에 대한 후속 처리를 수행하는 callback 함수를 인자로 전달한다.</li>
<li>이와 같은 Callback pattern은 통상 <code>Callback Hell - 중첩, 복잡도 상승</code>라고 부르는 가독성 문제를 일으킨다.</li>
</ul>
</li>
<li><p><code>Error 처리의 한계</code></p>
<ul>
<li>Callbakc Pattern의 가장 큰 단점은 <code>에러 처리가 곤란</code>하다는 점이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error가 발생했습니다&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;catch :&quot;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>위의 예제에서 try문 안의 setTimeout 함수는 설정된 1초가 지나면 콜백함수를 호출하고, 콜백함수는 에러를 발생시킨다.</li>
<li>하지만 콜백함수가 발생시킨 error는 catch문에서 잡아내지 못한다.</li>
<li>setTimeout함수의 콜백함수가 실행될 때 setTimeout함수는 이미 콜 스택에서 제거된 이후이다. (<code>콜 스택</code>과 <code>이벤트 루프</code> 참고)</li>
<li>그 말인 즉슨, setTimeout 함수의 콜백함수를 호출한 것(호출자-caller)이 setTimeout 함수가 아니라는 것을 의미한다.</li>
<li>에러는 호출자(caller) 방향으로 전파된다. (즉, 콜 스택의 아래 방향으로 전파됨)</li>
<li>따라서 setTimeout 함수의 콜백함수가 던진 에러는 catch문에서 잡을 수가 없는 것이다.</li>
</ul>
</li>
<li><p>위와 같은 콜백 헬, 에러 처리의 한계를 극복하기 위해 Promise Pattern이 등장하게 된다.</p>
</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ol>
<li><p>프로미스의 생성</p>
<ul>
<li>new Promise 생성자 함수 구문으로 Promise 인스턴스를 생성한다.</li>
<li>Promise 생성자 함수의 인자로 비동기 처리를 수행할 콜백 함수를 제공한다.</li>
<li>콜백 함수는 다시 resolve 함수와 reject 함수를 인자로 받는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// asynchronous code</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">/* successful */</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* failure */</span>) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>resolve, reject</p>
</li>
</ol>
<ul>
<li><p>Promise는 세 가지 state를 가진다.</p>
</li>
<li><table>
<thead>
<tr>
<th>state</th>
<th>의미</th>
<th>상태 변경 조건</th>
</tr>
</thead>
<tbody><tr>
<td>pending</td>
<td>비동기 처리가 아직 수행되지 않은 상태</td>
<td>프로미스가 생성된 직후 기본 상태</td>
</tr>
<tr>
<td>fulfilled</td>
<td>비동기 처리가 수행된 상태(성공)</td>
<td>resolve 함수 호출</td>
</tr>
<tr>
<td>rejected</td>
<td>비동기 처리가 수행된 상태(실패)</td>
<td>reject 함수 호출</td>
</tr>
</tbody></table>
</li>
<li><p>후속 처리를 위한 작업을 위해 resolve 함수의 인자로 비동기 처리 결과를 넘겨주고, reject 함수의 인자로 에러 객체를 넘겨주어 체이닝을 통해 후속처리를 진행한다.</p>
</li>
<li><p>resolve, reject 함수가 필요한 이유를 요약하면 다음과 같다.</p>
<ol>
<li>pending 상태의 프로미스를 settled(fulfilled or rejected) 상태로 변경하는 역할 수행</li>
<li>비동기 처리 결과를 후속 처리 메서드에 전달하는 역할 (프로미스 체이닝)</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>Promise 후속처리 메서드</p>
<ul>
<li><p>then</p>
<ul>
<li>첫 번째 인자 : 프로미스가 fulfilled 상태가 되었을 때 실행시킬 콜백 함수. 콜백 함수는 다시 첫 번째 인자로 프로미스가 resolve한 값을 받는다.</li>
<li>두 번째 인자 : 프로미스가 rejected 상태가 되었을 때 실행시킬 콜백 함수. 콜백 함수는 다시 첫 번째 인자로 프로미스가 reject한 값을 받는다.</li>
</ul>
</li>
<li><p>catch</p>
<ul>
<li>then의 두번째 인자로 넘겨준 callback함수가 에러 처리를 수행할 수 있지만, catch 메서드의 콜백함수로 error를 처리하도록 하자.</li>
</ul>
</li>
<li><p>finally</p>
<ul>
<li>Promise의 처리 결과와 상관없이 한 번 수행될 로직을 짠다.</li>
</ul>
</li>
<li><p>Promise 후속처리 메서드는 Promise 체이닝을 통한 후속처리를 위해 항상 프로미스를 반환한다.</p>
</li>
<li><p>만약 후속처리 메서드의 콜백함수가 명시적으로 프로미스가 아닌 값으로 반환을 해도 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성해 반환한다.</p>
</li>
</ul>
</li>
<li><p>Promise 정적 메서드</p>
<ol>
<li><p>Promise.resolve &#x2F; Promise.reject</p>
<ul>
<li>이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.</li>
</ul>
</li>
<li><p>Promise.all</p>
<ul>
<li>여러 비동기 처리를 묶어 병렬 처리할 때 사용.</li>
<li>모든 비동기 처리가 fulfilled 될 때 까지 기다리며, 전부 fulfilled 상태가 되면 각각의 resolve값들을 배열에 저장하고 해당 배열을 resolve하여 새로운 Promise를 반환한다.</li>
<li>비동기 처리 중 하나라도 reject가 되면 나머지 비동기 처리를 기다리지 않고 즉시 종료한다.</li>
</ul>
</li>
<li><p>Promise.race</p>
<ul>
<li>Promise.all 처럼 모든 비동기 처리가 fulfilled 되기를 기다리는 것이 아니라, 가장 먼저 fulfilled 된 프로미스가 resolve한 값을 resolve하여 새로운 Promise를 반환한다.</li>
</ul>
</li>
</ol>
</li>
<li><p>마이크로태스크큐</p>
</li>
</ol>
<ul>
<li><p>프로미스의 비동기 함수는 태스크 큐가 아닌 별도의 큐가 관리를 하는데, 이를 마이크로태스크 큐라고 한다.</p>
</li>
<li><p>마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2, 3, 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Async-x2F-Await"><a href="#Async-x2F-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h2><ol>
<li><p>async&#x2F;await 는 Promise를 기반으로 동작한다.</p>
<ul>
<li>Promise 후속처리 메서드 역시 콜백을 전달하는 callback pattern을 사용했지만,</li>
<li>async&#x2F;await 문법을 통해 후속 처리 메서드 없이 마치 동기적으로 돌아가는 것처럼 구현할 수 있게 되었다.</li>
</ul>
</li>
<li><p>async 함수</p>
<ul>
<li>await 키워드는 반드시 async 함수 내에서 사용해야한다.</li>
<li>async 함수는 언제나 프로미스를 반환한다.</li>
<li>async 함수 내에서 await 키워드를 만나면 이후의 코드는 마이크로태스크큐로 넘어간다.</li>
</ul>
</li>
<li><p>await 키워드</p>
<ul>
<li>프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 값을 반환한다. (프로미스를 반환하는 것은 아님.)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> promise;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li>await는 반드시 Promise 앞에서 사용해야한다.</li>
</ul>
</li>
<li><p>에러 처리</p>
<ul>
<li>try ~ catch 문을 사용.</li>
<li>async 함수 내에서 catch문으로 에러 처리를 하지 않으면 async함수는 발생한 에러를 reject하는 프로미스를 반환한다.<ul>
<li>이를 이용하여 async 함수의 후속 처리로 catch 메서드를 이어 붙일 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="최신-문법-Update"><a href="#최신-문법-Update" class="headerlink" title="최신 문법 Update"></a>최신 문법 Update</h2><ul>
<li>전역 환경에서는 async 함수로 래핑하지 않고 await 키워드 단독으로 사용할 수 있게 되었다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-10T11:50:00.995Z" title="2023. 1. 10. 오후 8:50:00">2023-01-10</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-15T12:01:57.023Z" title="2023. 1. 15. 오후 9:01:57">2023-01-15</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">13분안에 읽기 (약 1885 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/10/230110-js-builtin-methods/">Javasript 표준 내장 객체 Method (지속 업데이트 필요)</a></h1><div class="content"><h1 id="Javascript-표준-내장-객체"><a href="#Javascript-표준-내장-객체" class="headerlink" title="Javascript 표준 내장 객체"></a>Javascript 표준 내장 객체</h1><ul>
<li>본 포스팅은 패스트캠퍼스 박영웅 강사님의 강의를 기반으로 합니다.</li>
<li>본 포스팅의 메서드 구분 방법<ul>
<li>프로토타입 메서드 : <code>.</code>으로 시작합니다.</li>
<li>정적 메서드 : 클래스부터 시작합니다.</li>
</ul>
</li>
</ul>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul>
<li><p><code>.forEach()</code></p>
<ul>
<li>forEach메서드는 해당 메서드의 폴리필에서 볼 수 있듯이, 내가 원한다고해서 중간에 순회를 중단할 수 없다.<ul>
<li>for 반복문에서는 break 키워드를 통해 가능하다는 점이 차이. 배열의 요소 수가 굉장히 많은게 아니라면 가독성이 상대적으로 더 좋은 forEach를 사용하자.</li>
</ul>
</li>
<li>forEach내부의 콜백으로 async function을 제공하면 의도대로 작동하지 않는다.<ul>
<li>foreach 는 배열 요소를 순차적으로 돌면서 callback을 실행할 뿐, callback이 끝날때 까지 기다렸다가 다음 callback을 실행하는 것이 아니라고 한다. 즉, foreach 자신이 실행하는 코드가 비동기를 하든 안하든 관심이 없이 넘어간다는 것이다. (병렬 처리 느낌 script 로드할 때 async 속성 부여한 느낌)</li>
<li>위의 경우 대신 for 반복문 사용하기</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.map()</code></p>
<ul>
<li><p>각 요소를 순회하며 각각을 콜백 함수가 반환하는 값으로 대체하여 새로운 <code>배열</code>을 반환.</p>
</li>
<li><p>원본 배열과 length가 동일.</p>
</li>
<li><p>배열에 요소를 추가나 삭제할 필요 없이, 데이터를 공통적으로 가공할 때 유용해보인다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Neo&quot;</span>, <span class="attr">age</span>: <span class="number">85</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Lewis&quot;</span>, <span class="attr">age</span>: <span class="number">11</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> newUsers = users.<span class="title function_">map</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 3. 객체로 반환한다. 객체 리터럴을 반환하므로 소괄호로 묶어줌 (중괄호 구분)</span></span><br><span class="line">  ...user, <span class="comment">// 1. 요소의 기존 내용물을 열거하고,</span></span><br><span class="line">  <span class="attr">isValid</span>: <span class="literal">true</span>, <span class="comment">// 2. 새로운 내용을 더해서</span></span><br><span class="line">  <span class="attr">email</span>: <span class="literal">null</span>, <span class="comment">// 2. 새로운 내용을 더해서</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">const</span> userNames = users.<span class="title function_">map</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newUsers); <span class="comment">// [&#123; name: &#x27;Neo&#x27;, age: 85, isValid: true, email: null &#125;, ...]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userNames); <span class="comment">// [&#x27;Neo&#x27;, &#x27;Amy&#x27;, &#x27;Lewis&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>.includes()</code></p>
<ul>
<li>배열 내에 지정된 요소가 있는지 여부를 Boolean 값으로 반환</li>
<li>주의) <code>참조형</code> 데이터(객체)를 인자로 넘겨줄 땐 리터럴로 넘겨주면 안된다. 탐색 대상에 존재하는 참조형 데이터 자체를 변수에 담아서 사용하기.<ul>
<li>선행 개념 : <code>데이터의 가변성과 불변성</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>.every()</code></p>
<ul>
<li>대상 배열의 모든 요소가 콜백 테스트를 통과 (Truthy) 하는지 여부를 Boolean 값으로 반환</li>
<li>최초로 테스트가 실패하면 이후 테스트를 더 이상 진행하지 않고 false를 반환.</li>
</ul>
</li>
<li><p><code>.some()</code></p>
<ul>
<li>대상 배열 중 일부가 콜백 테스트를 통과하는지 여부를 Boolean 값으로 반환.</li>
<li>마찬가지로 첫 통과가 나오면 이후 콜백을 실행하지 않는다.</li>
</ul>
</li>
<li><p><code>.filter()</code></p>
<ul>
<li>대상 배열에서 콜백 테스트를 통과하는 요소들만으로 이루어진 새로운 배열을 반환.</li>
<li>모든 요소가 콜백 테스트를 통과하지 못하면 <code>빈 배열</code>을 반환</li>
</ul>
</li>
<li><p><code>.find()</code></p>
<ul>
<li>대상 배열에서 콜백 테스트를 통과하는 첫 번째 <code>요소</code>를 반환</li>
<li>최초로 테스트가 통과되면 이후 콜백은 실행하지 않는다.</li>
<li>모든 테스트 실패 시 <code>undefined</code> 반환</li>
<li>객체를 다룰 때 find 메서드의 반환값을 truthy, falsy로 활용할 수 있겠다.</li>
</ul>
</li>
<li><p><code>.findIndex()</code></p>
<ul>
<li><code>.find()</code>메서드와 동일, 찾은 요소의 인덱스를 반환</li>
<li>없으면 <code>-1</code> 반환.</li>
</ul>
</li>
<li><p><code>.at()</code></p>
<ul>
<li>대상 배열을 인덱싱</li>
<li>음수값을 사용하면 뒤에서부터 인덱싱. –&gt; 이 때 유용해보인다.</li>
</ul>
</li>
<li><p><code>.concat()</code></p>
<ul>
<li>배열을 병합.</li>
<li>스프레드 연산자로 대체가 가능하다.</li>
</ul>
</li>
<li><p><code>.reverse()</code></p>
<ul>
<li>대상 배열의 순서를 반전.</li>
<li>원본 배열을 직접 바꾼다. (부수 효과 O)</li>
</ul>
</li>
<li><p><code>.join()</code></p>
<ul>
<li>대상 배열의 모든 요소를 구분자로 연결한 <code>문자</code>를 반환</li>
</ul>
</li>
<li><p><code>.sort()</code></p>
<ul>
<li><p>원본 배열을 직접 바꾼다. (부수 효과 O)</p>
</li>
<li><p>대상 배열을 콜백의 반환 값에 따라 정렬</p>
<ul>
<li>음수 : a를 낮은 순서로 정렬</li>
<li>0 : 순서 변경 없음</li>
<li>양수 : b를 낮은 순서로 정렬</li>
</ul>
</li>
<li><p>콜백의 반환값 부호에 집중하는 것이니 내부의 로직을 조금 더 복잡하게 가져가면 단순 숫자 정렬이 아닌, 객체 데이터를 다루는 데에도 용이해보인다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Neo&quot;</span>, <span class="attr">age</span>: <span class="number">85</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Lewis&quot;</span>, <span class="attr">age</span>: <span class="number">11</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">age</span> - b.<span class="property">age</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(users); <span class="comment">// [ Lewis객체, Amy객체, Neo객체 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// users.sort((a, b) =&gt; b.age - a.age)</span></span><br><span class="line"><span class="comment">// console.log(users) // [ Neo객체, Amy객체, Lewis객체 ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>콜백을 제공하지 않으면, 요소를 문자열로 변환하고 유니코드 코드 포인트 순서로 정렬.</p>
</li>
</ul>
</li>
<li><p><code>.flat()</code></p>
<ul>
<li>대상 배열의 모든 하위 배열을 지정한 깊이(depth)까지 이어붙인 새로운 배열을 반환.</li>
<li>깊이의 기본값 : 1</li>
</ul>
</li>
</ul>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li><p><code>Object.assign()</code></p>
<ul>
<li>하나 이상의 출처 객체로부터 대상 객체로 속성을 복사하고 대상 객체를 반환.</li>
<li>첫 번째 인수가 대상 객체가 되고, 두 번째 인수 이후부터 모두 출처 객체가 된다.</li>
<li>객체 내 각 프로퍼티는 고유하다. 고로 프로퍼티가 중복되면 나중에 복사되어 들어오는 프로퍼티가 이전 것을 덮어쓴다.</li>
<li>대상 객체(원본)가 수정된다. 고로 원본을 유지해야한다면, 대상객체에 빈 객체(<code>&#123;&#125;</code>)를 제공하자.</li>
</ul>
</li>
<li><p><code>Object.entries()</code></p>
<ul>
<li>주어진 객체의 각 속성과 값으로 하나의 배열을 만들어 요소로 추가한 2차원 배열을 반환<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Heropy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">85</span>,</span><br><span class="line">  <span class="attr">isValid</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&quot;thesecon@gmail.com&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(user)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name Heropy</span></span><br><span class="line"><span class="comment">// age 85</span></span><br><span class="line"><span class="comment">// isValid true</span></span><br><span class="line"><span class="comment">// email thesecon@gmail.com</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Object.freeze(), Object.isfrozen()</code></p>
<ul>
<li>주어진 객체를 변경할 수 없도록 동결하거나, 동결 여부를 확인</li>
</ul>
</li>
<li><p><code>Object.seal(), Object.isSealed()</code></p>
<ul>
<li>동결과 다른 점은 밀봉 후에도 이미 존재하는 속성의 값은 변경 가능. 동결과 마찬가지로 여전히 추가&#x2F;삭제 불가</li>
</ul>
</li>
<li><p><code>Object.defineProperty(객체, 프로퍼티, 옵션 객체)</code></p>
<ul>
<li><p>주어진 객체에 속성을 추가하거나, 특성을 변경</p>
</li>
<li><p>옵션들</p>
<ol>
<li>enumerable : false</li>
<li>configurable : false</li>
<li>writable : false</li>
<li>value : undefined</li>
<li>get : undefined</li>
<li>set : undefined</li>
</ol>
</li>
<li><p>일반적인 객체는 1<del>3번 모두 true. 본 메서드로 프로퍼티 생성 시 해당 프로퍼티는 1</del>3번 모두 false</p>
</li>
<li><p>중요 : <code>getter</code>, <code>setter</code></p>
</li>
<li><p>getter는 프로퍼티에 접근(get)할 때 실행되는 get() 함수.</p>
</li>
<li><p>setter는 프로퍼티의 값으로 무언갈 할당(set)할 때 실행되는 set() 함수.</p>
</li>
<li><p>값을 얻으려고 할 때, 혹은 값을 할당하려 할 때, <code>추가적인 로직을 부여할 수 있음</code></p>
</li>
<li><p>즉, 데이터를 감시할 수 있게 된다는 점이 아주 중요하다.</p>
</li>
<li><p>getter와 setter는 함수지만, 흔히 알고있는 함수의 호출 형태로 실행되는 것이 아님!</p>
</li>
<li><p>참고) 객체의 속성 제거엔 <code>delete</code> 키워드</p>
</li>
<li><p>참고) 식별자 앞의 underscore(_)는 해당 식별자는 숨기겠다는 개발자의 의도가 담겨있음. (실제로 숨김처리가 되는 건 아님.)</p>
<ul>
<li><pre><code class="javascript">const user = &#123;
  firstName: &quot;bongbong&quot;,
  lastName: &quot;Ko&quot;,
&#125;;

Object.defineProperty(user, &quot;fullName&quot;, &#123;
  get() &#123;
    return `Full Name is $&#123;this.lastName&#125; $&#123;this.firstName&#125;`;
  &#125;,

  set(str) &#123;
    const nameArr = str.split(&quot; &quot;);
    this.lastName = nameArr[0];
    this.firstName = nameArr[1];
  &#125;,
&#125;);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>통신용 데이터 포맷 (즉, 기본적으로 서버와의 통신은 JSON이다.)</li>
<li>문자, 숫자, Boolean, null, 객체, 배열만 지원.</li>
<li>후행 쉼표 허용 X</li>
<li>큰 따옴표만 허용</li>
<li><code>JSON.stringify()</code></li>
<li><code>JSON.parse()</code></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-07T12:09:10.238Z" title="2023. 1. 7. 오후 9:09:10">2023-01-07</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-25T08:10:21.460Z" title="2023. 1. 25. 오후 5:10:21">2023-01-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">8분안에 읽기 (약 1186 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/07/230107-js-regexp/">Javascript 정규표현식 적응하기 (++꾸준히 업데이트)</a></h1><div class="content"><h1 id="정규-표현식"><a href="#정규-표현식" class="headerlink" title="정규 표현식"></a>정규 표현식</h1><ul>
<li>지난 알고리즘 스터디 영찬님 발표 때 정규표현식을 처음 접했고, 이후 문제풀이에서 문자열 탐색 문제에 적용해보고자 간단하게 공부한 내용을 정리해봅니다.<br><a target="_blank" rel="noopener" href="https://heropy.blog/2018/10/28/regexp/">Heropy님 블로그에 너무 정리가 잘되어있다.</a></li>
</ul>
<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><ul>
<li><p>정규표현식은 기본적으로 문자열을 탐색하기 위한 방법의 하나로, 문자열 메서드와 조합하여 많이 사용한다고 한다.</p>
</li>
<li><p><code>패턴과 플래그를 이용하여 생성한 정규표현식</code>을 이용하여 <code>대상 문자열</code>을 탐색하여 <code>결과</code>를 얻어낸다! 로 요약이 가능하겠다.</p>
</li>
<li><p><code>패턴</code>을 문제 상황의 요구 조건에 맞게 얼마나 잘 표현을 하느냐가 중요해보인다.</p>
</li>
<li><p><code>패턴</code>을 작성하는데 사용되는 여러 클래스들이 존재한다.</p>
</li>
<li><p>정규표현식 생성에는 리터럴 방식(<code>/pattern/flag</code>)과 RegExp 생성자 함수를 이용한 객체 생성 두 가지가 있다.</p>
<ul>
<li>전자는 코드를 작성하고 있는 시점에 정확한 패턴을 알고있을 때 사용. 보통 사용하게 될 방식.</li>
<li>후자는 상황에 따라 정규표현식을 동적으로 생성해야할 때 사용. 생성자 함수의 인자로 패턴과 플래그를 넘겨준다 (상황에 따라!).</li>
</ul>
</li>
<li><p>정규표현식은 많이 알아두면 알아둘 수록 문자열 탐색에 있어서 아주 편리할 것 같다.</p>
</li>
<li><p>근데 그 표현식이 너무 많아보이는구나하ㅏ함….</p>
</li>
</ul>
<h2 id="정규표현식-메소드"><a href="#정규표현식-메소드" class="headerlink" title="정규표현식 메소드"></a>정규표현식 메소드</h2><table>
<thead>
<tr>
<th>메소드</th>
<th>문법</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>exec</td>
<td>정규식.exec(문자열)</td>
<td>일치하는 하나의 정보(Array) 반환</td>
</tr>
<tr>
<td>test</td>
<td>정규식.test(문자열)</td>
<td>일치 여부(Boolean) 반환</td>
</tr>
<tr>
<td>search</td>
<td>문자열.search(정규식)</td>
<td>일치하는 문자열의 인덱스(Number) 반환</td>
</tr>
<tr>
<td>replace</td>
<td>문자열.replace(정규식, 바꿀 문자)</td>
<td>일치하는 문자열을 지정 문자열로 교체하고 교체된 문자열 반환</td>
</tr>
<tr>
<td>match</td>
<td>문자열.match(정규식)</td>
<td>일치하는 문자열의 배열 반환</td>
</tr>
<tr>
<td>split</td>
<td>문자열.split(정규식)</td>
<td>일치하는 문자열을 분할하여 배열(Array)로 반환</td>
</tr>
</tbody></table>
<ul>
<li>단순히 true or false 값을 원한다면 test, search 메소드를 이용하자.</li>
</ul>
<h2 id="플래그"><a href="#플래그" class="headerlink" title="플래그"></a>플래그</h2><table>
<thead>
<tr>
<th>플래그</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>g</code>(global)</td>
<td>모든 문자와 여러 줄 일치(global)</td>
</tr>
<tr>
<td><code>i</code>(ignore)</td>
<td>영어 대소문자를 구분 않고 일치</td>
</tr>
<tr>
<td><code>m</code>(multiLine)</td>
<td>여러 줄 일치</td>
</tr>
</tbody></table>
<h2 id="패턴"><a href="#패턴" class="headerlink" title="패턴"></a>패턴</h2><table>
<thead>
<tr>
<th>정규식 패턴</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>[a-z]</code></td>
<td>a부터 z 사이의 문자 구간에 일치(영어 소문자)</td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td>A부터 Z 사이의 문자 구간에 일치(영어 대문자)</td>
</tr>
<tr>
<td><code>^</code></td>
<td>줄의 시작에서 일치 <code>/^abc/</code></td>
</tr>
<tr>
<td><code>$</code></td>
<td>줄의 끝에서 일치 <code>/xyz$/</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>임의의 한 문자와 일치</td>
</tr>
<tr>
<td><code>a&amp;verbar;b</code></td>
<td>a 또는 b와 일치 <code>/h..p/</code></td>
</tr>
<tr>
<td><code>ab?</code></td>
<td>b가 없거나 b와 일치 <code>https?</code></td>
</tr>
<tr>
<td><code>&#123;3&#125;</code></td>
<td>3개 연속 일치</td>
</tr>
<tr>
<td><code>&#123;3,&#125;</code></td>
<td>3개 이상 연속 일치</td>
</tr>
<tr>
<td><code>&#123;3,5&#125;</code></td>
<td>3~5개 연속 일치</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>a 또는 b 또는 c와 일치</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>a부터 z 사이의 문자 구간에 일치(영어 소문자)</td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td>A부터 Z 사이의 문자 구간에 일치(영어 대문자)</td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td>0부터 9 사이의 문자 구간에 일치(숫자)</td>
</tr>
<tr>
<td><code>[가-힣]</code></td>
<td>가부터 힣 사이의 문자 구간에 일치(한글)</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>a 또는 b 또는 c가 아닌 나머지 문자에 일치(부정)</td>
</tr>
<tr>
<td><code>\</code></td>
<td>이스케이프 문자, <code>/\.\?\/\$\^/</code></td>
</tr>
<tr>
<td><code>\w</code>(word)</td>
<td>63개 문자(영문 대소문자 52개 + 숫자 10개 + _(underscore))에 일치</td>
</tr>
<tr>
<td><code>\b</code>(boundary)</td>
<td>63개 문자(영문 대소문자 52개 + 숫자 10개 + _(underscore))가 아닌 나머지 문자에 일치하는 경계(boundary)</td>
</tr>
<tr>
<td><code>\d</code>(digit)</td>
<td>숫자에 일치</td>
</tr>
<tr>
<td><code>\s</code>(space)</td>
<td>공백(Space, Tab, 줄바꿈 등)에 일치</td>
</tr>
<tr>
<td><code>(?=)</code></td>
<td>앞쪽 일치(Lookahead)</td>
</tr>
<tr>
<td><code>(?&lt;=)</code></td>
<td>뒤쪽 일치(Lookbehind)</td>
</tr>
<tr>
<td><code>*</code></td>
<td>0회 이상 연속으로 반복되는 문자와 가능한 많이 일치, <code>&#123;0,&#125;</code>와 동일</td>
</tr>
<tr>
<td><code>*?</code></td>
<td>0회 이상 연속으로 반복되는 문자와 가능한 적게 일치(lazy), <code>&#123;0&#125;</code>와 동일</td>
</tr>
<tr>
<td><code>+</code></td>
<td>1회 이상 연속으로 반복되는 문자에 가능한 많이 일치, <code>&#123;1,&#125;</code>와 동일</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>1회 이상 연속으로 반복되는 문자에 가능한 적게 일치(lazy), <code>&#123;1&#125;</code>와 동일</td>
</tr>
<tr>
<td><code>()</code></td>
<td>그룹화</td>
</tr>
</tbody></table>
<ul>
<li>주의) 줄 끝이라 함은 기본적으로 문자열의 가장 끝을 의미. (end quote의 바로 앞) 이 때, 줄 바꿈을 반영하려면 <code>m</code>flag를 사용</li>
</ul>
<h2 id="정규-표현식-예시"><a href="#정규-표현식-예시" class="headerlink" title="정규 표현식 예시"></a>정규 표현식 예시</h2><ul>
<li><code>/\bf\w&#123;1,&#125;\b/g</code> : f로 시작하는 모든 영단어 검색</li>
<li><code>/.&#123;1,&#125;(?=@)/g</code> : @ 앞쪽의 연속되는 모든 문자 (주로 이메일 처리할 때)</li>
<li><code>/(?&lt;=@).&#123;1,&#125;/g</code> : @ 뒤쪽의 연속되는 모든 문자 (주로 이메일 처리할 때)</li>
<li><code>문자열.replace(/\s/g, &quot;&quot;)</code> : 공백 처리할 때</li>
<li><code>str.match(/\((.*)\)/)[1]</code> : 괄호 사이 값 추출</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-05T08:47:28.032Z" title="2023. 1. 5. 오후 5:47:28">2023-01-05</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-09T13:41:37.602Z" title="2023. 1. 9. 오후 10:41:37">2023-01-09</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">9분안에 읽기 (약 1343 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/05/230105-js-intersection-observer-api/">Intersection Observer API</a></h1><div class="content"><h1 id="Intersection-Observer-API"><a href="#Intersection-Observer-API" class="headerlink" title="Intersection Observer API"></a>Intersection Observer API</h1><p>Javascrip 1차과제에서 무한 스크롤을 구현하기 위해 공부한 내용을 정리.<br><a target="_blank" rel="noopener" href="https://heropy.blog/2019/10/27/intersection-observer/">Heropy님의 블로그를 참조합니다.</a></p>
<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>기준이 되는 root요소와 관찰 대상인 target의 가시성(교차) 정보를 이용해서 비동기적으로 로직을 구현할 수 있다.</p>
<h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ol>
<li>scroll 이벤트가 가지는 한계를 극복. scroll 이벤트와 같이 짧은 시간안에 매우 많은 횟수로 발생될 수 있는 경우 브라우저 렌더링 성능이나 이벤트 연속 호출과 같은 문제가 발생한다.</li>
<li>Intersection Observer API를 이용해 scroll 이벤트로 퉁치는 것이 아닌 내가 설정해놓은 특정 조건에 의해 로직이 실행될 수 있도록 하였다.</li>
</ol>
<h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><ul>
<li><p>new IntersectionObserver 생성자로 IntersectionObserver 객체를 생성할 수 있다.</p>
<ol>
<li><p>생성자 호출 시 필수적으로 콜백함수를 인자로 제공해야한다. 이 콜백함수는 추후에 observer가 발동될 때 실행될 코드들이 들어갈 함수다.</p>
</li>
<li><p>두번째 인자로 observer 발동 조건을 조정할 수 있는 option을 인자로 제공할 수 있다. (제공하지 않으면 기본 세팅값으로 작동한다.)</p>
<ol>
<li>threshold : observer를 발동시키기 위해 관찰 대상(target)의 가시성이 얼마나 필요한지 백분율로 표시한 값을 가진다. threshold는 양방향으로 작동한다.<ol>
<li>기본값으로 0을 지니고 있다. 이 의미는 target의 가장 자리 픽셀이 Root 범위를 교차하는 순간 observer가 발동된다는 뜻이다.</li>
<li>쉽게 말해 <code>threshold : 0</code>의 의미는 root요소를 기준으로 보이자마자 혹은, 사라지자마자 observer가 발동된다는 뜻이다.</li>
<li>threshold 값이 0.3이라면 target의 가시성이 30% 즉, 30%정도 보이는 순간 observer가 실행된다는 뜻이다.</li>
<li>threshold의 값으로 배열을 지정해줄 수 있는데, [0, 0.3, 1] 이라고 하면 target의 가시성이 0%, 30%, 100% 일 때 모두 observer를 발동시킨다는 의미다.</li>
</ol>
</li>
<li>root : 관찰 대상(target)의 가시성을 확인할 때 사용되는 뷰포트 요소.<ol>
<li>target의 조상 요소여야 한다.</li>
<li>기본값은 브라우저 viewport이며, root값이 null이거나 지정되지 않을 때 기본값으로 설정된다.</li>
</ol>
</li>
<li>rootMargin : root가 가진 여백.<ol>
<li>root요소의 각 측면의 bounding box를 수축시키거나 증가시킬 수 있다.</li>
<li>이는 target과의 교차성을 계산하기 전에 미리 적용되는 값이므로, 교차를 탐지하는 지점을 조정할 때 유용하게 사용될 것으로 보인다.</li>
<li>(root가 viewport일 때) rootMargin 기본값은 0px 0px 0px 0px이므로 우리가 화면으로 보는 viewport의 사각박스가 교차점의 기준이 될 것이다.</li>
</ol>
</li>
</ol>
</li>
<li><p>1번에서 언급한 콜백함수는 또 다시 첫번째 인자로 IntersectionObserverEntry 인스턴스가 담긴 배열을 제공받는다.</p>
<ol>
<li>IntersectionObserverEntry로부터 target에 대한 다양한 정보들이 담긴 속성들을 제공받는다.<ol>
<li>boundingClientRect : target의 사각형 정보를 반환.</li>
<li>intersectionRect : target과 root가 겹치는 영역에 대한 사각형 정보를 반환.</li>
<li>intersectionRatio : target이 root와 얼마나 겹치는지의 수치를 0.0~1.0 사이의 숫자로 반환. (intersectionRect와 boundingClientRect 영역의 비율)</li>
<li>isIntersecting : observer가 발동되는 그 순간 root와 target이 겹쳐있는가? 즉 교차하고 있는가? Boolean값으로 반환.</li>
<li>rootBounds : root의 사각형 정보를 반환.</li>
<li>target : 관찰 대상(Element)을 반환.</li>
<li>time : 문서가 작성된 시간을 기준으로 교차 상태 변경이 발생한 시간을 나타내는 DOMHighResTimeStamp를 반환.</li>
</ol>
</li>
<li>콜백함수의 두번째 인자로 콜백이 실행되는 해당 인스턴스를 제공받는다(observer).<ol>
<li>콜백의 인자로 받기 때문에 observer가 발동하고 콜백 내부에서 unobserve() 메서드를 이용해서 관찰을 중지시킬 수도 있다.</li>
</ol>
</li>
</ol>
</li>
<li><p>Methods</p>
<ol>
<li>observe() : target을 관찰하기 시작.</li>
<li>unobserve() : target 관찰을 중지.</li>
<li>disconnect() : IntersectionObserver 인스턴스가 관찰하는 모든 요소의 관찰을 중지.</li>
</ol>
</li>
<li><p>기억해야할 사항들</p>
<ol>
<li>observer는 최초 관찰을 지시받을 때(observe 메소드 호출)에도 발동되며, 이 후 관찰 조건에 충족이 될 때 마다 반복 발동된다.</li>
<li>여기서 말하는 <code>isIntersecting</code> 즉 교차란, <code>root와 target이 겹쳐있는가 ?</code> 를 의미한다. 교차하는 순간을 말하는 것이 아니다. (정확히 말해서 교차하는 순간은 threshold : 0 의 경우가 될 수 있겠다.)</li>
<li><code>가시성</code>의 의미를 잘 파악하자. <code>root 영역 내에 target이 얼마나 들어와있는가</code> 가 되겠다. (사용자의 화면기준이 아니라 <code>root 영역 내에서 얼만큼 보이는가</code> 이 차이를 이해하자.)</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="예시-초간단-주의"><a href="#예시-초간단-주의" class="headerlink" title="예시 (초간단 주의)"></a>예시 (초간단 주의)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n + <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: orange;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: royalblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> $divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> options = &#123; <span class="attr">threshold</span>: <span class="number">0.5</span> &#125;; <span class="comment">// 생성자 함수의 두번째 인자로 넘겨줄 옵션</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> props = entries[<span class="number">0</span>]; <span class="comment">// intersectionObserverEntry에 접근</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (props.<span class="property">intersectionRatio</span> &gt; <span class="number">0.5</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// observer 발동 조건</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;쨘!&quot;</span>); <span class="comment">// 조건 충족 시 실행될 코드</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, options);</span></span><br><span class="line"><span class="language-javascript">    observer.<span class="title function_">observe</span>($divs[<span class="number">3</span>]); <span class="comment">// target($divs[3] 요소)의 관찰을 시작.</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-02T05:15:20.267Z" title="2023. 1. 2. 오후 2:15:20">2023-01-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-02T05:15:51.423Z" title="2023. 1. 2. 오후 2:15:51">2023-01-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">몇 초안에 읽기 (약 0 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/02/230102-js-global-variable/">전역 변수의 문제점과 억제 방안</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-02T04:31:13.586Z" title="2023. 1. 2. 오후 1:31:13">2023-01-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-02T05:05:12.403Z" title="2023. 1. 2. 오후 2:05:12">2023-01-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">4분안에 읽기 (약 634 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/02/230102-js-data-type/">데이터 타입이 필요한 이유</a></h1><div class="content"><h1 id="데이터-타입이-필요한-이유가-뭘까요"><a href="#데이터-타입이-필요한-이유가-뭘까요" class="headerlink" title="데이터 타입이 필요한 이유가 뭘까요"></a>데이터 타입이 필요한 이유가 뭘까요</h1><p>Modern Javascript Deep Dive의 내용을 요약했습니다.</p>
<h2 id="값은-메모리에-저장하고-참조할-수-있어야한다"><a href="#값은-메모리에-저장하고-참조할-수-있어야한다" class="headerlink" title="값은 메모리에 저장하고 참조할 수 있어야한다."></a>값은 메모리에 저장하고 참조할 수 있어야한다.</h2><ul>
<li>값을 저장할 경우<ul>
<li>값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야한다.</li>
<li>다시 말해, 몇 바이트의 메모리 공간을 사용해야 <code>낭비와 손실없이</code> 값을 저장할 수 있는지 알아야 한다.</li>
<li>자바스크립트 엔진은 데이터의 타입에 따라 정해진 크기의 메모리 공간을 확보한다.</li>
</ul>
</li>
<li>값을 참조하는 경우<ul>
<li>예를 들어, score라는 변수에 숫자 100이라는 값이 저장되어있는 경우, 식별자 score를 통해 숫자 값 100이 저장되어있는 메모리 공간의 선두 메모리 셀의 주소를 찾아간다.</li>
<li>이때 값을 정상적으로 참조하려면 한번에 읽어들여야할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야한다. 그렇게 하지 못하면 값이 훼손될 가능성이 있다.</li>
<li>자바스크립트 엔진은 score 변수에 저장된 값을 숫자 타입으로 인식하고, 숫자 타입은 8바이트의 고정단위로 저장되므로 8바이트 단위로 읽어들인다.</li>
</ul>
</li>
<li>메모리에서 읽어들인 값의 해석<ul>
<li>모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다.</li>
<li>메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.</li>
<li>예를 들어, 메모리에 저장된 값 <code>0100 0001</code>을 숫자로 해석하면 65지만, 문자열로 해석하면 ‘A’이다.</li>
</ul>
</li>
</ul>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ol>
<li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어들인 2진수를 어떻게 해석해야할지 결정하기 위해</li>
<li>ECMAScript 사양에서는 문자열과 숫자타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지 않다. 따라서 문자열과 숫자 타입 외의 데이터 타입은 확보되는 메모리 공간의 크기가 자바스크립트 엔진 제조사의 구현에 따라 다를 수 있다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-02T03:38:20.015Z" title="2023. 1. 2. 오후 12:38:20">2023-01-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2023-01-02T04:22:11.747Z" title="2023. 1. 2. 오후 1:22:11">2023-01-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a><span> / </span><a class="link-muted" href="/categories/javascript/algorithm/">algorithm</a></span><span class="level-item">4분안에 읽기 (약 549 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/02/230102-js-NaN/">Javascript NaN 에 관하여</a></h1><div class="content"><h1 id="NaN-Not-A-Number"><a href="#NaN-Not-A-Number" class="headerlink" title="NaN (Not A Number)"></a>NaN (Not A Number)</h1><ul>
<li>프로그래머스 입문 숨어있는 숫자의 덧셈(1) 문제를 풀며 들었던 의문과 함께 정리해본다.</li>
</ul>
<h2 id="숨어있는-숫자의-덧셈-1-문제-설명"><a href="#숨어있는-숫자의-덧셈-1-문제-설명" class="headerlink" title="숨어있는 숫자의 덧셈(1) 문제 설명"></a>숨어있는 숫자의 덧셈(1) 문제 설명</h2><hr>
<h3 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h3><ul>
<li>문자열 my_string이 매개변수로 주어집니다. my_string안의 모든 자연수들의 합을 return하도록 solution 함수를 완성해주세요.</li>
</ul>
<h3 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h3><ul>
<li>1 ≤ my_string의 길이 ≤ 1,000</li>
<li>my_string은 소문자, 대문자 그리고 한자리 자연수로만 구성되어있습니다.</li>
</ul>
<h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table>
<thead>
<tr>
<th>my_string</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td>“aAb1B2cC34oOp”</td>
<td>10</td>
</tr>
<tr>
<td>“1a2b3c4d123”</td>
<td>16</td>
</tr>
</tbody></table>
<h3 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h3><ul>
<li>입출력 예 #1 : “aAb1B2cC34oOp”안의 한자리 자연수는 1, 2, 3, 4 입니다. 따라서 1 + 2 + 3 + 4 &#x3D; 10 을 return합니다.</li>
<li>입출력 예 #2 : “1a2b3c4d123Z”안의 한자리 자연수는 1, 2, 3, 4, 1, 2, 3 입니다. 따라서 1 + 2 + 3 + 4 + 1 + 2 + 3 &#x3D; 16 을 return합니다.</li>
</ul>
<h3 id="유의사항"><a href="#유의사항" class="headerlink" title="유의사항"></a>유의사항</h3><ul>
<li>연속된 숫자도 각각 한 자리 숫자로 취급합니다.</li>
</ul>
<h2 id="최종-풀이"><a href="#최종-풀이" class="headerlink" title="최종 풀이"></a>최종 풀이</h2><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">my_string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> my_string_arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(my_string);</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  my_string_arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(element)) &#123;</span><br><span class="line">      answer += <span class="title class_">Number</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NaN이란"><a href="#NaN이란" class="headerlink" title="NaN이란 ?"></a>NaN이란 ?</h2><hr>
<ul>
<li>NaN은 Not A Number 즉, 숫자가 아니라는 의미의 숫자 타입의 데이터이며, 전역 객체의 속성이다. (실제로 브라우저환경이나, Node.js환경에서 전역 객체를 찍어보면, 내부에 NaN이 들어있다.)</li>
<li>NaN을 반환하는 연산 다섯가지<ol>
<li>숫자로서 읽을 수 없음 (parseInt(“어쩌구”), Number(undefined))</li>
<li>결과가 허수인 수학 계산식 (Math.sqrt(-1))</li>
<li>피연산자가 NaN (7 ** NaN)</li>
<li>정의할 수 없는 계산식 (0 * Infinity)</li>
<li>문자열을 포함하면서 덧셈이 아닌 계산식 (“가” &#x2F; 3)</li>
</ol>
</li>
</ul>
<h2 id="NaN-판별법"><a href="#NaN-판별법" class="headerlink" title="NaN 판별법"></a>NaN 판별법</h2><hr>
<ul>
<li>NaN의 판별<ol>
<li><code>Number.isNaN()</code> 또는 <code>isNaN()</code> 을 이용.</li>
</ol>
<ul>
<li>isNaN()과 Number.isNaN()의 차이를 주의. isNaN은 현재 값이 NaN이거나, 숫자로 변환했을 때 NaN이 되면 참을 반환하지만, Number.isNaN은 현재 값이 NaN이어야만 참을 반환.</li>
</ul>
<ol start="2">
<li><code>자기 자신과 같지 않음</code>을 이용<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">valueIsNaN</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v !== v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">valueIsNaN</span>(<span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">valueIsNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>(주의) 일부 배열 메서드는 NaN을 찾을 수 없다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="title class_">NaN</span>, <span class="number">12</span>];</span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>); <span class="comment">// -1 (false)</span></span><br><span class="line">arr.<span class="title function_">includes</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(n)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="Bongsee"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Bongsee</p><p class="is-size-6 is-block">Record TIL &amp; Error</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Republic of Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/bongsee" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/bongsee"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/TIL/"><span class="level-start"><span class="level-item">TIL</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/Weekly-Recap/"><span class="level-start"><span class="level-item">Weekly Recap</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/algorithm/"><span class="level-start"><span class="level-item">algorithm</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/bundler/"><span class="level-start"><span class="level-item">bundler</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/error/"><span class="level-start"><span class="level-item">error</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/html-css/"><span class="level-start"><span class="level-item">html/css</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/javascript/algorithm/"><span class="level-start"><span class="level-item">algorithm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/wil/"><span class="level-start"><span class="level-item">wil</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-01T16:03:09.243Z">2023-02-02</time></p><p class="title"><a href="/2023/02/02/til-230131-js/">TIL 230131 javascript</a></p><p class="categories"><a href="/categories/TIL/">TIL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-29T09:42:08.384Z">2023-01-29</time></p><p class="title"><a href="/2023/01/29/230129-js-storage/">브라우저 저장소 종류 4가지</a></p><p class="categories"><a href="/categories/TIL/">TIL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-28T09:10:07.617Z">2023-01-28</time></p><p class="title"><a href="/2023/01/28/230128-spa-routing/">SPA와 Routing</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-25T08:11:37.075Z">2023-01-25</time></p><p class="title"><a href="/2023/01/25/wil-2301-4th/">23년 1월 4주차 주간회고</a></p><p class="categories"><a href="/categories/Weekly-Recap/">Weekly Recap</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-15T08:40:42.423Z">2023-01-15</time></p><p class="title"><a href="/2023/01/15/230114-js-error%EC%B2%98%EB%A6%AC/">에러 처리</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">2월 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">1월 2023</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">12월 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/API/"><span class="tag">API</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MegabyteSchool/"><span class="tag">MegabyteSchool</span><span class="tag">42</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TIL/"><span class="tag">TIL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/clone/"><span class="tag">clone</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/error/"><span class="tag">error</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etc/"><span class="tag">etc</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/parcel/"><span class="tag">parcel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/scss/"><span class="tag">scss</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/"><span class="tag">개발자취업부트캠프</span><span class="tag">42</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EA%B5%90%EC%9C%A1/"><span class="tag">국비지원교육</span><span class="tag">42</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%82%B4%EC%9D%BC%EB%B0%B0%EC%9B%80%EC%B9%B4%EB%93%9C/"><span class="tag">내일배움카드</span><span class="tag">42</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%A9%94%EA%B0%80%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%8A%A4%EC%BF%A8/"><span class="tag">메가바이트스쿨</span><span class="tag">42</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"><span class="tag">패스트캠퍼스</span><span class="tag">42</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Bonglog</a><p class="is-size-7"><span>&copy; 2023 BS K</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>